// Code generated from parser/ZggParser.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // ZggParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 111, 852,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 3,
	2, 3, 2, 5, 2, 59, 10, 2, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 65, 10, 4, 7, 4,
	67, 10, 4, 12, 4, 14, 4, 70, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 87, 10, 6,
	12, 6, 14, 6, 90, 11, 6, 3, 6, 3, 6, 3, 6, 5, 6, 95, 10, 6, 3, 6, 5, 6,
	98, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 103, 10, 6, 5, 6, 105, 10, 6, 3, 6,
	3, 6, 3, 6, 5, 6, 110, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	118, 10, 6, 3, 6, 3, 6, 5, 6, 122, 10, 6, 3, 6, 3, 6, 7, 6, 126, 10, 6,
	12, 6, 14, 6, 129, 11, 6, 3, 6, 3, 6, 3, 6, 5, 6, 134, 10, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 146, 10, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 151, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 158,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 164, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 173, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	5, 6, 181, 10, 6, 3, 6, 3, 6, 5, 6, 185, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 195, 10, 6, 12, 6, 14, 6, 198, 11, 6, 3,
	6, 3, 6, 5, 6, 202, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 6, 6, 208, 10, 6, 13,
	6, 14, 6, 209, 3, 6, 5, 6, 213, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5,
	6, 220, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 7, 6, 235, 10, 6, 12, 6, 14, 6, 238, 11, 6, 3, 6,
	3, 6, 3, 6, 5, 6, 243, 10, 6, 3, 6, 5, 6, 246, 10, 6, 3, 6, 3, 6, 5, 6,
	250, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 257, 10, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	272, 10, 6, 3, 6, 3, 6, 5, 6, 276, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	282, 10, 6, 3, 6, 5, 6, 285, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 291,
	10, 6, 12, 6, 14, 6, 294, 11, 6, 3, 6, 3, 6, 5, 6, 298, 10, 6, 3, 7, 3,
	7, 3, 7, 5, 7, 303, 10, 7, 3, 7, 3, 7, 3, 8, 5, 8, 308, 10, 8, 3, 8, 3,
	8, 3, 9, 3, 9, 5, 9, 314, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 319, 10, 9, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 326, 10, 10, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 6, 13, 355, 10, 13, 13, 13, 14, 13, 356, 3, 13, 3,
	13, 3, 13, 5, 13, 362, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 6, 13, 373, 10, 13, 13, 13, 14, 13, 374, 3, 13, 3,
	13, 3, 13, 5, 13, 380, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5,
	13, 398, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 454, 10, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 468,
	10, 13, 3, 13, 3, 13, 5, 13, 472, 10, 13, 3, 13, 3, 13, 3, 13, 7, 13, 477,
	10, 13, 12, 13, 14, 13, 480, 11, 13, 3, 14, 3, 14, 3, 14, 7, 14, 485, 10,
	14, 12, 14, 14, 14, 488, 11, 14, 3, 14, 5, 14, 491, 10, 14, 3, 14, 3, 14,
	5, 14, 495, 10, 14, 3, 14, 3, 14, 5, 14, 499, 10, 14, 3, 15, 3, 15, 3,
	15, 3, 15, 7, 15, 505, 10, 15, 12, 15, 14, 15, 508, 11, 15, 3, 15, 5, 15,
	511, 10, 15, 5, 15, 513, 10, 15, 3, 15, 3, 15, 3, 16, 5, 16, 518, 10, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 526, 10, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 5, 16, 533, 10, 16, 5, 16, 535, 10, 16, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7,
	17, 548, 10, 17, 12, 17, 14, 17, 551, 11, 17, 3, 17, 3, 17, 3, 17, 5, 17,
	556, 10, 17, 3, 17, 5, 17, 559, 10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 17, 7, 17, 568, 10, 17, 12, 17, 14, 17, 571, 11, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 579, 10, 17, 3, 18, 3, 18, 3,
	18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 591, 10, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 601, 10,
	20, 12, 20, 14, 20, 604, 11, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5,
	21, 611, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 626, 10, 22, 12, 22, 14, 22,
	629, 11, 22, 3, 22, 3, 22, 3, 22, 5, 22, 634, 10, 22, 3, 22, 5, 22, 637,
	10, 22, 3, 22, 3, 22, 5, 22, 641, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 7, 22, 649, 10, 22, 12, 22, 14, 22, 652, 11, 22, 3, 22, 3, 22,
	3, 22, 5, 22, 657, 10, 22, 3, 22, 5, 22, 660, 10, 22, 3, 22, 3, 22, 5,
	22, 664, 10, 22, 3, 22, 3, 22, 5, 22, 668, 10, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 7, 22, 676, 10, 22, 12, 22, 14, 22, 679, 11, 22, 3,
	22, 3, 22, 3, 22, 5, 22, 684, 10, 22, 3, 22, 5, 22, 687, 10, 22, 3, 22,
	3, 22, 5, 22, 691, 10, 22, 3, 22, 3, 22, 5, 22, 695, 10, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 703, 10, 22, 12, 22, 14, 22, 706,
	11, 22, 3, 22, 5, 22, 709, 10, 22, 5, 22, 711, 10, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 721, 10, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 5, 22, 728, 10, 22, 3, 22, 3, 22, 5, 22, 732, 10,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 740, 10, 22, 12, 22,
	14, 22, 743, 11, 22, 3, 22, 5, 22, 746, 10, 22, 5, 22, 748, 10, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 756, 10, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 5, 22, 763, 10, 22, 3, 22, 3, 22, 5, 22, 767, 10,
	22, 3, 22, 3, 22, 5, 22, 771, 10, 22, 3, 23, 5, 23, 774, 10, 23, 3, 23,
	3, 23, 3, 23, 5, 23, 779, 10, 23, 3, 24, 3, 24, 3, 24, 5, 24, 784, 10,
	24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 804, 10,
	25, 12, 25, 14, 25, 807, 11, 25, 3, 25, 3, 25, 3, 25, 5, 25, 812, 10, 25,
	3, 25, 5, 25, 815, 10, 25, 3, 25, 3, 25, 5, 25, 819, 10, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 828, 10, 25, 3, 26, 3, 26,
	3, 26, 5, 26, 833, 10, 26, 3, 27, 3, 27, 7, 27, 837, 10, 27, 12, 27, 14,
	27, 840, 11, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	5, 28, 850, 10, 28, 3, 28, 2, 4, 24, 38, 29, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 2, 13, 3, 2, 82, 83, 3, 2, 21, 22, 4, 2, 57, 60, 96, 97, 3, 2, 104,
	105, 3, 2, 101, 103, 3, 2, 99, 100, 3, 2, 74, 75, 3, 2, 41, 42, 5, 2, 62,
	65, 77, 81, 98, 98, 3, 2, 55, 56, 3, 2, 3, 4, 2, 1022, 2, 58, 3, 2, 2,
	2, 4, 60, 3, 2, 2, 2, 6, 68, 3, 2, 2, 2, 8, 71, 3, 2, 2, 2, 10, 297, 3,
	2, 2, 2, 12, 302, 3, 2, 2, 2, 14, 307, 3, 2, 2, 2, 16, 311, 3, 2, 2, 2,
	18, 320, 3, 2, 2, 2, 20, 327, 3, 2, 2, 2, 22, 331, 3, 2, 2, 2, 24, 397,
	3, 2, 2, 2, 26, 498, 3, 2, 2, 2, 28, 500, 3, 2, 2, 2, 30, 534, 3, 2, 2,
	2, 32, 578, 3, 2, 2, 2, 34, 580, 3, 2, 2, 2, 36, 583, 3, 2, 2, 2, 38, 590,
	3, 2, 2, 2, 40, 610, 3, 2, 2, 2, 42, 770, 3, 2, 2, 2, 44, 773, 3, 2, 2,
	2, 46, 783, 3, 2, 2, 2, 48, 827, 3, 2, 2, 2, 50, 832, 3, 2, 2, 2, 52, 834,
	3, 2, 2, 2, 54, 849, 3, 2, 2, 2, 56, 59, 5, 24, 13, 2, 57, 59, 5, 6, 4,
	2, 58, 56, 3, 2, 2, 2, 58, 57, 3, 2, 2, 2, 59, 3, 3, 2, 2, 2, 60, 61, 5,
	6, 4, 2, 61, 5, 3, 2, 2, 2, 62, 64, 5, 10, 6, 2, 63, 65, 7, 86, 2, 2, 64,
	63, 3, 2, 2, 2, 64, 65, 3, 2, 2, 2, 65, 67, 3, 2, 2, 2, 66, 62, 3, 2, 2,
	2, 67, 70, 3, 2, 2, 2, 68, 66, 3, 2, 2, 2, 68, 69, 3, 2, 2, 2, 69, 7, 3,
	2, 2, 2, 70, 68, 3, 2, 2, 2, 71, 72, 7, 90, 2, 2, 72, 73, 5, 6, 4, 2, 73,
	74, 7, 91, 2, 2, 74, 9, 3, 2, 2, 2, 75, 298, 5, 8, 5, 2, 76, 298, 5, 34,
	18, 2, 77, 298, 5, 36, 19, 2, 78, 298, 5, 32, 17, 2, 79, 298, 5, 16, 9,
	2, 80, 81, 7, 12, 2, 2, 81, 82, 7, 107, 2, 2, 82, 104, 7, 88, 2, 2, 83,
	88, 7, 107, 2, 2, 84, 85, 7, 85, 2, 2, 85, 87, 7, 107, 2, 2, 86, 84, 3,
	2, 2, 2, 87, 90, 3, 2, 2, 2, 88, 86, 3, 2, 2, 2, 88, 89, 3, 2, 2, 2, 89,
	94, 3, 2, 2, 2, 90, 88, 3, 2, 2, 2, 91, 92, 7, 85, 2, 2, 92, 93, 7, 51,
	2, 2, 93, 95, 7, 107, 2, 2, 94, 91, 3, 2, 2, 2, 94, 95, 3, 2, 2, 2, 95,
	97, 3, 2, 2, 2, 96, 98, 7, 85, 2, 2, 97, 96, 3, 2, 2, 2, 97, 98, 3, 2,
	2, 2, 98, 105, 3, 2, 2, 2, 99, 100, 7, 51, 2, 2, 100, 102, 7, 107, 2, 2,
	101, 103, 7, 85, 2, 2, 102, 101, 3, 2, 2, 2, 102, 103, 3, 2, 2, 2, 103,
	105, 3, 2, 2, 2, 104, 83, 3, 2, 2, 2, 104, 99, 3, 2, 2, 2, 104, 105, 3,
	2, 2, 2, 105, 106, 3, 2, 2, 2, 106, 107, 7, 89, 2, 2, 107, 298, 5, 8, 5,
	2, 108, 110, 7, 19, 2, 2, 109, 108, 3, 2, 2, 2, 109, 110, 3, 2, 2, 2, 110,
	111, 3, 2, 2, 2, 111, 112, 7, 20, 2, 2, 112, 121, 7, 107, 2, 2, 113, 114,
	7, 88, 2, 2, 114, 117, 5, 24, 13, 2, 115, 116, 7, 85, 2, 2, 116, 118, 5,
	24, 13, 2, 117, 115, 3, 2, 2, 2, 117, 118, 3, 2, 2, 2, 118, 119, 3, 2,
	2, 2, 119, 120, 7, 89, 2, 2, 120, 122, 3, 2, 2, 2, 121, 113, 3, 2, 2, 2,
	121, 122, 3, 2, 2, 2, 122, 123, 3, 2, 2, 2, 123, 127, 7, 90, 2, 2, 124,
	126, 5, 14, 8, 2, 125, 124, 3, 2, 2, 2, 126, 129, 3, 2, 2, 2, 127, 125,
	3, 2, 2, 2, 127, 128, 3, 2, 2, 2, 128, 130, 3, 2, 2, 2, 129, 127, 3, 2,
	2, 2, 130, 298, 7, 91, 2, 2, 131, 132, 7, 107, 2, 2, 132, 134, 7, 87, 2,
	2, 133, 131, 3, 2, 2, 2, 133, 134, 3, 2, 2, 2, 134, 135, 3, 2, 2, 2, 135,
	136, 7, 5, 2, 2, 136, 137, 5, 24, 13, 2, 137, 138, 7, 86, 2, 2, 138, 139,
	5, 24, 13, 2, 139, 140, 7, 86, 2, 2, 140, 141, 5, 24, 13, 2, 141, 142,
	5, 8, 5, 2, 142, 298, 3, 2, 2, 2, 143, 144, 7, 107, 2, 2, 144, 146, 7,
	87, 2, 2, 145, 143, 3, 2, 2, 2, 145, 146, 3, 2, 2, 2, 146, 147, 3, 2, 2,
	2, 147, 150, 7, 5, 2, 2, 148, 149, 7, 107, 2, 2, 149, 151, 7, 85, 2, 2,
	150, 148, 3, 2, 2, 2, 150, 151, 3, 2, 2, 2, 151, 152, 3, 2, 2, 2, 152,
	153, 7, 107, 2, 2, 153, 154, 7, 6, 2, 2, 154, 157, 5, 24, 13, 2, 155, 156,
	9, 2, 2, 2, 156, 158, 5, 24, 13, 2, 157, 155, 3, 2, 2, 2, 157, 158, 3,
	2, 2, 2, 158, 159, 3, 2, 2, 2, 159, 160, 5, 8, 5, 2, 160, 298, 3, 2, 2,
	2, 161, 162, 7, 107, 2, 2, 162, 164, 7, 87, 2, 2, 163, 161, 3, 2, 2, 2,
	163, 164, 3, 2, 2, 2, 164, 165, 3, 2, 2, 2, 165, 166, 7, 9, 2, 2, 166,
	167, 5, 8, 5, 2, 167, 168, 7, 8, 2, 2, 168, 169, 5, 24, 13, 2, 169, 298,
	3, 2, 2, 2, 170, 171, 7, 107, 2, 2, 171, 173, 7, 87, 2, 2, 172, 170, 3,
	2, 2, 2, 172, 173, 3, 2, 2, 2, 173, 174, 3, 2, 2, 2, 174, 175, 7, 8, 2,
	2, 175, 176, 5, 24, 13, 2, 176, 177, 5, 8, 5, 2, 177, 298, 3, 2, 2, 2,
	178, 180, 7, 11, 2, 2, 179, 181, 7, 107, 2, 2, 180, 179, 3, 2, 2, 2, 180,
	181, 3, 2, 2, 2, 181, 298, 3, 2, 2, 2, 182, 184, 7, 10, 2, 2, 183, 185,
	7, 107, 2, 2, 184, 183, 3, 2, 2, 2, 184, 185, 3, 2, 2, 2, 185, 298, 3,
	2, 2, 2, 186, 187, 7, 7, 2, 2, 187, 188, 5, 12, 7, 2, 188, 196, 5, 8, 5,
	2, 189, 190, 7, 14, 2, 2, 190, 191, 7, 7, 2, 2, 191, 192, 5, 12, 7, 2,
	192, 193, 5, 8, 5, 2, 193, 195, 3, 2, 2, 2, 194, 189, 3, 2, 2, 2, 195,
	198, 3, 2, 2, 2, 196, 194, 3, 2, 2, 2, 196, 197, 3, 2, 2, 2, 197, 201,
	3, 2, 2, 2, 198, 196, 3, 2, 2, 2, 199, 200, 7, 14, 2, 2, 200, 202, 5, 8,
	5, 2, 201, 199, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 298, 3, 2, 2, 2,
	203, 204, 7, 32, 2, 2, 204, 205, 5, 24, 13, 2, 205, 207, 7, 90, 2, 2, 206,
	208, 5, 18, 10, 2, 207, 206, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 207,
	3, 2, 2, 2, 209, 210, 3, 2, 2, 2, 210, 212, 3, 2, 2, 2, 211, 213, 5, 20,
	11, 2, 212, 211, 3, 2, 2, 2, 212, 213, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2,
	214, 215, 7, 91, 2, 2, 215, 298, 3, 2, 2, 2, 216, 298, 7, 17, 2, 2, 217,
	219, 7, 18, 2, 2, 218, 220, 5, 24, 13, 2, 219, 218, 3, 2, 2, 2, 219, 220,
	3, 2, 2, 2, 220, 298, 3, 2, 2, 2, 221, 222, 7, 19, 2, 2, 222, 298, 7, 107,
	2, 2, 223, 224, 7, 19, 2, 2, 224, 225, 7, 107, 2, 2, 225, 226, 7, 61, 2,
	2, 226, 298, 5, 24, 13, 2, 227, 228, 7, 19, 2, 2, 228, 229, 7, 12, 2, 2,
	229, 230, 7, 107, 2, 2, 230, 249, 7, 88, 2, 2, 231, 236, 7, 107, 2, 2,
	232, 233, 7, 85, 2, 2, 233, 235, 7, 107, 2, 2, 234, 232, 3, 2, 2, 2, 235,
	238, 3, 2, 2, 2, 236, 234, 3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 242,
	3, 2, 2, 2, 238, 236, 3, 2, 2, 2, 239, 240, 7, 85, 2, 2, 240, 241, 7, 51,
	2, 2, 241, 243, 7, 107, 2, 2, 242, 239, 3, 2, 2, 2, 242, 243, 3, 2, 2,
	2, 243, 245, 3, 2, 2, 2, 244, 246, 7, 85, 2, 2, 245, 244, 3, 2, 2, 2, 245,
	246, 3, 2, 2, 2, 246, 250, 3, 2, 2, 2, 247, 248, 7, 51, 2, 2, 248, 250,
	7, 107, 2, 2, 249, 231, 3, 2, 2, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3,
	2, 2, 2, 250, 251, 3, 2, 2, 2, 251, 252, 7, 89, 2, 2, 252, 298, 5, 8, 5,
	2, 253, 254, 9, 3, 2, 2, 254, 256, 5, 24, 13, 2, 255, 257, 7, 69, 2, 2,
	256, 255, 3, 2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258,
	259, 5, 28, 15, 2, 259, 298, 3, 2, 2, 2, 260, 261, 9, 3, 2, 2, 261, 298,
	5, 8, 5, 2, 262, 263, 7, 24, 2, 2, 263, 275, 5, 8, 5, 2, 264, 265, 7, 25,
	2, 2, 265, 266, 7, 88, 2, 2, 266, 267, 7, 107, 2, 2, 267, 268, 7, 89, 2,
	2, 268, 271, 5, 8, 5, 2, 269, 270, 7, 26, 2, 2, 270, 272, 5, 8, 5, 2, 271,
	269, 3, 2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 276, 3, 2, 2, 2, 273, 274,
	7, 26, 2, 2, 274, 276, 5, 8, 5, 2, 275, 264, 3, 2, 2, 2, 275, 273, 3, 2,
	2, 2, 276, 298, 3, 2, 2, 2, 277, 278, 7, 28, 2, 2, 278, 281, 5, 24, 13,
	2, 279, 280, 7, 85, 2, 2, 280, 282, 5, 24, 13, 2, 281, 279, 3, 2, 2, 2,
	281, 282, 3, 2, 2, 2, 282, 298, 3, 2, 2, 2, 283, 285, 7, 19, 2, 2, 284,
	283, 3, 2, 2, 2, 284, 285, 3, 2, 2, 2, 285, 286, 3, 2, 2, 2, 286, 287,
	7, 29, 2, 2, 287, 288, 5, 24, 13, 2, 288, 292, 7, 90, 2, 2, 289, 291, 5,
	48, 25, 2, 290, 289, 3, 2, 2, 2, 291, 294, 3, 2, 2, 2, 292, 290, 3, 2,
	2, 2, 292, 293, 3, 2, 2, 2, 293, 295, 3, 2, 2, 2, 294, 292, 3, 2, 2, 2,
	295, 296, 7, 91, 2, 2, 296, 298, 3, 2, 2, 2, 297, 75, 3, 2, 2, 2, 297,
	76, 3, 2, 2, 2, 297, 77, 3, 2, 2, 2, 297, 78, 3, 2, 2, 2, 297, 79, 3, 2,
	2, 2, 297, 80, 3, 2, 2, 2, 297, 109, 3, 2, 2, 2, 297, 133, 3, 2, 2, 2,
	297, 145, 3, 2, 2, 2, 297, 163, 3, 2, 2, 2, 297, 172, 3, 2, 2, 2, 297,
	178, 3, 2, 2, 2, 297, 182, 3, 2, 2, 2, 297, 186, 3, 2, 2, 2, 297, 203,
	3, 2, 2, 2, 297, 216, 3, 2, 2, 2, 297, 217, 3, 2, 2, 2, 297, 221, 3, 2,
	2, 2, 297, 223, 3, 2, 2, 2, 297, 227, 3, 2, 2, 2, 297, 253, 3, 2, 2, 2,
	297, 260, 3, 2, 2, 2, 297, 262, 3, 2, 2, 2, 297, 277, 3, 2, 2, 2, 297,
	284, 3, 2, 2, 2, 298, 11, 3, 2, 2, 2, 299, 300, 5, 32, 17, 2, 300, 301,
	7, 86, 2, 2, 301, 303, 3, 2, 2, 2, 302, 299, 3, 2, 2, 2, 302, 303, 3, 2,
	2, 2, 303, 304, 3, 2, 2, 2, 304, 305, 5, 24, 13, 2, 305, 13, 3, 2, 2, 2,
	306, 308, 7, 27, 2, 2, 307, 306, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308,
	309, 3, 2, 2, 2, 309, 310, 5, 48, 25, 2, 310, 15, 3, 2, 2, 2, 311, 313,
	5, 24, 13, 2, 312, 314, 7, 69, 2, 2, 313, 312, 3, 2, 2, 2, 313, 314, 3,
	2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 318, 5, 28, 15, 2, 316, 317, 7, 70,
	2, 2, 317, 319, 5, 8, 5, 2, 318, 316, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2,
	319, 17, 3, 2, 2, 2, 320, 321, 7, 33, 2, 2, 321, 322, 5, 26, 14, 2, 322,
	323, 7, 87, 2, 2, 323, 325, 5, 6, 4, 2, 324, 326, 7, 34, 2, 2, 325, 324,
	3, 2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 19, 3, 2, 2, 2, 327, 328, 7, 35,
	2, 2, 328, 329, 7, 87, 2, 2, 329, 330, 5, 6, 4, 2, 330, 21, 3, 2, 2, 2,
	331, 332, 9, 4, 2, 2, 332, 23, 3, 2, 2, 2, 333, 334, 8, 13, 1, 2, 334,
	335, 9, 5, 2, 2, 335, 398, 7, 107, 2, 2, 336, 398, 5, 34, 18, 2, 337, 398,
	5, 36, 19, 2, 338, 339, 7, 84, 2, 2, 339, 398, 7, 107, 2, 2, 340, 398,
	7, 107, 2, 2, 341, 398, 5, 42, 22, 2, 342, 343, 7, 100, 2, 2, 343, 398,
	5, 24, 13, 28, 344, 345, 7, 94, 2, 2, 345, 398, 5, 24, 13, 27, 346, 347,
	7, 73, 2, 2, 347, 398, 5, 24, 13, 26, 348, 349, 7, 13, 2, 2, 349, 354,
	7, 90, 2, 2, 350, 351, 5, 24, 13, 2, 351, 352, 7, 52, 2, 2, 352, 353, 5,
	24, 13, 2, 353, 355, 3, 2, 2, 2, 354, 350, 3, 2, 2, 2, 355, 356, 3, 2,
	2, 2, 356, 354, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 361, 3, 2, 2, 2,
	358, 359, 7, 14, 2, 2, 359, 360, 7, 52, 2, 2, 360, 362, 5, 24, 13, 2, 361,
	358, 3, 2, 2, 2, 361, 362, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 364,
	7, 91, 2, 2, 364, 398, 3, 2, 2, 2, 365, 366, 7, 13, 2, 2, 366, 367, 5,
	24, 13, 2, 367, 372, 7, 90, 2, 2, 368, 369, 5, 26, 14, 2, 369, 370, 7,
	52, 2, 2, 370, 371, 5, 24, 13, 2, 371, 373, 3, 2, 2, 2, 372, 368, 3, 2,
	2, 2, 373, 374, 3, 2, 2, 2, 374, 372, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2,
	375, 379, 3, 2, 2, 2, 376, 377, 7, 14, 2, 2, 377, 378, 7, 52, 2, 2, 378,
	380, 5, 24, 13, 2, 379, 376, 3, 2, 2, 2, 379, 380, 3, 2, 2, 2, 380, 381,
	3, 2, 2, 2, 381, 382, 7, 91, 2, 2, 382, 398, 3, 2, 2, 2, 383, 398, 5, 32,
	17, 2, 384, 385, 7, 88, 2, 2, 385, 386, 5, 24, 13, 2, 386, 387, 7, 89,
	2, 2, 387, 398, 3, 2, 2, 2, 388, 389, 7, 30, 2, 2, 389, 390, 7, 107, 2,
	2, 390, 398, 5, 24, 13, 6, 391, 392, 7, 30, 2, 2, 392, 393, 5, 8, 5, 2,
	393, 394, 5, 24, 13, 5, 394, 398, 3, 2, 2, 2, 395, 396, 7, 31, 2, 2, 396,
	398, 5, 24, 13, 4, 397, 333, 3, 2, 2, 2, 397, 336, 3, 2, 2, 2, 397, 337,
	3, 2, 2, 2, 397, 338, 3, 2, 2, 2, 397, 340, 3, 2, 2, 2, 397, 341, 3, 2,
	2, 2, 397, 342, 3, 2, 2, 2, 397, 344, 3, 2, 2, 2, 397, 346, 3, 2, 2, 2,
	397, 348, 3, 2, 2, 2, 397, 365, 3, 2, 2, 2, 397, 383, 3, 2, 2, 2, 397,
	384, 3, 2, 2, 2, 397, 388, 3, 2, 2, 2, 397, 391, 3, 2, 2, 2, 397, 395,
	3, 2, 2, 2, 398, 478, 3, 2, 2, 2, 399, 400, 12, 25, 2, 2, 400, 401, 7,
	54, 2, 2, 401, 477, 5, 24, 13, 25, 402, 403, 12, 24, 2, 2, 403, 404, 9,
	6, 2, 2, 404, 477, 5, 24, 13, 25, 405, 406, 12, 23, 2, 2, 406, 407, 9,
	7, 2, 2, 407, 477, 5, 24, 13, 24, 408, 409, 12, 22, 2, 2, 409, 410, 9,
	8, 2, 2, 410, 477, 5, 24, 13, 23, 411, 412, 12, 21, 2, 2, 412, 413, 7,
	71, 2, 2, 413, 477, 5, 24, 13, 22, 414, 415, 12, 20, 2, 2, 415, 416, 7,
	72, 2, 2, 416, 477, 5, 24, 13, 21, 417, 418, 12, 19, 2, 2, 418, 419, 7,
	76, 2, 2, 419, 477, 5, 24, 13, 20, 420, 421, 12, 18, 2, 2, 421, 422, 5,
	22, 12, 2, 422, 423, 5, 24, 13, 19, 423, 477, 3, 2, 2, 2, 424, 425, 12,
	17, 2, 2, 425, 426, 7, 36, 2, 2, 426, 477, 5, 24, 13, 18, 427, 428, 12,
	16, 2, 2, 428, 429, 7, 6, 2, 2, 429, 477, 5, 24, 13, 17, 430, 431, 12,
	15, 2, 2, 431, 432, 7, 6, 2, 2, 432, 433, 5, 24, 13, 2, 433, 434, 9, 2,
	2, 2, 434, 435, 5, 24, 13, 16, 435, 477, 3, 2, 2, 2, 436, 437, 12, 14,
	2, 2, 437, 438, 7, 67, 2, 2, 438, 477, 5, 24, 13, 15, 439, 440, 12, 13,
	2, 2, 440, 441, 7, 68, 2, 2, 441, 477, 5, 24, 13, 14, 442, 443, 12, 10,
	2, 2, 443, 444, 7, 95, 2, 2, 444, 445, 5, 24, 13, 2, 445, 446, 7, 87, 2,
	2, 446, 447, 5, 24, 13, 11, 447, 477, 3, 2, 2, 2, 448, 449, 12, 9, 2, 2,
	449, 450, 7, 70, 2, 2, 450, 477, 5, 24, 13, 10, 451, 453, 12, 38, 2, 2,
	452, 454, 7, 69, 2, 2, 453, 452, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454,
	455, 3, 2, 2, 2, 455, 477, 5, 28, 15, 2, 456, 457, 12, 33, 2, 2, 457, 458,
	7, 84, 2, 2, 458, 477, 7, 107, 2, 2, 459, 460, 12, 32, 2, 2, 460, 461,
	7, 92, 2, 2, 461, 462, 5, 24, 13, 2, 462, 463, 7, 93, 2, 2, 463, 477, 3,
	2, 2, 2, 464, 465, 12, 31, 2, 2, 465, 467, 7, 92, 2, 2, 466, 468, 5, 24,
	13, 2, 467, 466, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2,
	469, 471, 7, 87, 2, 2, 470, 472, 5, 24, 13, 2, 471, 470, 3, 2, 2, 2, 471,
	472, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 477, 7, 93, 2, 2, 474, 475,
	12, 3, 2, 2, 475, 477, 7, 94, 2, 2, 476, 399, 3, 2, 2, 2, 476, 402, 3,
	2, 2, 2, 476, 405, 3, 2, 2, 2, 476, 408, 3, 2, 2, 2, 476, 411, 3, 2, 2,
	2, 476, 414, 3, 2, 2, 2, 476, 417, 3, 2, 2, 2, 476, 420, 3, 2, 2, 2, 476,
	424, 3, 2, 2, 2, 476, 427, 3, 2, 2, 2, 476, 430, 3, 2, 2, 2, 476, 436,
	3, 2, 2, 2, 476, 439, 3, 2, 2, 2, 476, 442, 3, 2, 2, 2, 476, 448, 3, 2,
	2, 2, 476, 451, 3, 2, 2, 2, 476, 456, 3, 2, 2, 2, 476, 459, 3, 2, 2, 2,
	476, 464, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478,
	476, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 25, 3, 2, 2, 2, 480, 478, 3,
	2, 2, 2, 481, 486, 5, 24, 13, 2, 482, 483, 7, 85, 2, 2, 483, 485, 5, 24,
	13, 2, 484, 482, 3, 2, 2, 2, 485, 488, 3, 2, 2, 2, 486, 484, 3, 2, 2, 2,
	486, 487, 3, 2, 2, 2, 487, 499, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 489,
	491, 5, 24, 13, 2, 490, 489, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 492,
	3, 2, 2, 2, 492, 494, 9, 2, 2, 2, 493, 495, 5, 24, 13, 2, 494, 493, 3,
	2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 499, 3, 2, 2, 2, 496, 497, 7, 36, 2,
	2, 497, 499, 5, 24, 13, 2, 498, 481, 3, 2, 2, 2, 498, 490, 3, 2, 2, 2,
	498, 496, 3, 2, 2, 2, 499, 27, 3, 2, 2, 2, 500, 512, 7, 88, 2, 2, 501,
	506, 5, 30, 16, 2, 502, 503, 7, 85, 2, 2, 503, 505, 5, 30, 16, 2, 504,
	502, 3, 2, 2, 2, 505, 508, 3, 2, 2, 2, 506, 504, 3, 2, 2, 2, 506, 507,
	3, 2, 2, 2, 507, 510, 3, 2, 2, 2, 508, 506, 3, 2, 2, 2, 509, 511, 7, 85,
	2, 2, 510, 509, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 513, 3, 2, 2, 2,
	512, 501, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514,
	515, 7, 89, 2, 2, 515, 29, 3, 2, 2, 2, 516, 518, 7, 51, 2, 2, 517, 516,
	3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 526, 5, 24,
	13, 2, 520, 526, 5, 8, 5, 2, 521, 522, 7, 90, 2, 2, 522, 523, 5, 24, 13,
	2, 523, 524, 7, 91, 2, 2, 524, 526, 3, 2, 2, 2, 525, 517, 3, 2, 2, 2, 525,
	520, 3, 2, 2, 2, 525, 521, 3, 2, 2, 2, 526, 535, 3, 2, 2, 2, 527, 528,
	7, 107, 2, 2, 528, 529, 7, 87, 2, 2, 529, 535, 5, 24, 13, 2, 530, 532,
	7, 103, 2, 2, 531, 533, 9, 9, 2, 2, 532, 531, 3, 2, 2, 2, 532, 533, 3,
	2, 2, 2, 533, 535, 3, 2, 2, 2, 534, 525, 3, 2, 2, 2, 534, 527, 3, 2, 2,
	2, 534, 530, 3, 2, 2, 2, 535, 31, 3, 2, 2, 2, 536, 537, 5, 38, 20, 2, 537,
	538, 9, 10, 2, 2, 538, 539, 5, 24, 13, 2, 539, 579, 3, 2, 2, 2, 540, 541,
	7, 107, 2, 2, 541, 542, 7, 61, 2, 2, 542, 579, 5, 24, 13, 2, 543, 544,
	7, 92, 2, 2, 544, 549, 7, 107, 2, 2, 545, 546, 7, 85, 2, 2, 546, 548, 7,
	107, 2, 2, 547, 545, 3, 2, 2, 2, 548, 551, 3, 2, 2, 2, 549, 547, 3, 2,
	2, 2, 549, 550, 3, 2, 2, 2, 550, 555, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2,
	552, 553, 7, 85, 2, 2, 553, 554, 7, 51, 2, 2, 554, 556, 7, 107, 2, 2, 555,
	552, 3, 2, 2, 2, 555, 556, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 559,
	7, 85, 2, 2, 558, 557, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 560, 3, 2,
	2, 2, 560, 561, 7, 93, 2, 2, 561, 562, 7, 61, 2, 2, 562, 579, 5, 24, 13,
	2, 563, 564, 7, 90, 2, 2, 564, 569, 7, 107, 2, 2, 565, 566, 7, 85, 2, 2,
	566, 568, 7, 107, 2, 2, 567, 565, 3, 2, 2, 2, 568, 571, 3, 2, 2, 2, 569,
	567, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 572, 3, 2, 2, 2, 571, 569,
	3, 2, 2, 2, 572, 573, 7, 90, 2, 2, 573, 574, 7, 61, 2, 2, 574, 579, 5,
	24, 13, 2, 575, 576, 7, 51, 2, 2, 576, 577, 7, 61, 2, 2, 577, 579, 5, 24,
	13, 2, 578, 536, 3, 2, 2, 2, 578, 540, 3, 2, 2, 2, 578, 543, 3, 2, 2, 2,
	578, 563, 3, 2, 2, 2, 578, 575, 3, 2, 2, 2, 579, 33, 3, 2, 2, 2, 580, 581,
	9, 11, 2, 2, 581, 582, 5, 38, 20, 2, 582, 35, 3, 2, 2, 2, 583, 584, 5,
	38, 20, 2, 584, 585, 9, 11, 2, 2, 585, 37, 3, 2, 2, 2, 586, 587, 8, 20,
	1, 2, 587, 588, 7, 84, 2, 2, 588, 591, 7, 107, 2, 2, 589, 591, 7, 107,
	2, 2, 590, 586, 3, 2, 2, 2, 590, 589, 3, 2, 2, 2, 591, 602, 3, 2, 2, 2,
	592, 593, 12, 6, 2, 2, 593, 594, 7, 84, 2, 2, 594, 601, 7, 107, 2, 2, 595,
	596, 12, 4, 2, 2, 596, 597, 7, 92, 2, 2, 597, 598, 5, 24, 13, 2, 598, 599,
	7, 93, 2, 2, 599, 601, 3, 2, 2, 2, 600, 592, 3, 2, 2, 2, 600, 595, 3, 2,
	2, 2, 601, 604, 3, 2, 2, 2, 602, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2,
	603, 39, 3, 2, 2, 2, 604, 602, 3, 2, 2, 2, 605, 611, 7, 41, 2, 2, 606,
	611, 7, 42, 2, 2, 607, 611, 7, 43, 2, 2, 608, 611, 7, 44, 2, 2, 609, 611,
	7, 45, 2, 2, 610, 605, 3, 2, 2, 2, 610, 606, 3, 2, 2, 2, 610, 607, 3, 2,
	2, 2, 610, 608, 3, 2, 2, 2, 610, 609, 3, 2, 2, 2, 611, 41, 3, 2, 2, 2,
	612, 771, 5, 40, 21, 2, 613, 771, 7, 47, 2, 2, 614, 771, 7, 48, 2, 2, 615,
	771, 7, 46, 2, 2, 616, 771, 9, 12, 2, 2, 617, 771, 5, 50, 26, 2, 618, 771,
	7, 15, 2, 2, 619, 771, 7, 16, 2, 2, 620, 621, 7, 12, 2, 2, 621, 640, 7,
	88, 2, 2, 622, 627, 7, 107, 2, 2, 623, 624, 7, 85, 2, 2, 624, 626, 7, 107,
	2, 2, 625, 623, 3, 2, 2, 2, 626, 629, 3, 2, 2, 2, 627, 625, 3, 2, 2, 2,
	627, 628, 3, 2, 2, 2, 628, 633, 3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 630,
	631, 7, 85, 2, 2, 631, 632, 7, 51, 2, 2, 632, 634, 7, 107, 2, 2, 633, 630,
	3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 636, 3, 2, 2, 2, 635, 637, 7, 85,
	2, 2, 636, 635, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 641, 3, 2, 2, 2,
	638, 639, 7, 51, 2, 2, 639, 641, 7, 107, 2, 2, 640, 622, 3, 2, 2, 2, 640,
	638, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 642, 3, 2, 2, 2, 642, 643,
	7, 89, 2, 2, 643, 771, 5, 8, 5, 2, 644, 663, 7, 88, 2, 2, 645, 650, 7,
	107, 2, 2, 646, 647, 7, 85, 2, 2, 647, 649, 7, 107, 2, 2, 648, 646, 3,
	2, 2, 2, 649, 652, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 650, 651, 3, 2, 2,
	2, 651, 656, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 653, 654, 7, 85, 2, 2, 654,
	655, 7, 51, 2, 2, 655, 657, 7, 107, 2, 2, 656, 653, 3, 2, 2, 2, 656, 657,
	3, 2, 2, 2, 657, 659, 3, 2, 2, 2, 658, 660, 7, 85, 2, 2, 659, 658, 3, 2,
	2, 2, 659, 660, 3, 2, 2, 2, 660, 664, 3, 2, 2, 2, 661, 662, 7, 51, 2, 2,
	662, 664, 7, 107, 2, 2, 663, 645, 3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 663,
	664, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665, 668, 7, 89, 2, 2, 666, 668,
	7, 107, 2, 2, 667, 644, 3, 2, 2, 2, 667, 666, 3, 2, 2, 2, 668, 669, 3,
	2, 2, 2, 669, 670, 7, 53, 2, 2, 670, 771, 5, 24, 13, 2, 671, 690, 7, 88,
	2, 2, 672, 677, 7, 107, 2, 2, 673, 674, 7, 85, 2, 2, 674, 676, 7, 107,
	2, 2, 675, 673, 3, 2, 2, 2, 676, 679, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2,
	677, 678, 3, 2, 2, 2, 678, 683, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680,
	681, 7, 85, 2, 2, 681, 682, 7, 51, 2, 2, 682, 684, 7, 107, 2, 2, 683, 680,
	3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 686, 3, 2, 2, 2, 685, 687, 7, 85,
	2, 2, 686, 685, 3, 2, 2, 2, 686, 687, 3, 2, 2, 2, 687, 691, 3, 2, 2, 2,
	688, 689, 7, 51, 2, 2, 689, 691, 7, 107, 2, 2, 690, 672, 3, 2, 2, 2, 690,
	688, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 695,
	7, 89, 2, 2, 693, 695, 7, 107, 2, 2, 694, 671, 3, 2, 2, 2, 694, 693, 3,
	2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 697, 7, 53, 2, 2, 697, 771, 5, 8, 5,
	2, 698, 710, 7, 90, 2, 2, 699, 704, 5, 46, 24, 2, 700, 701, 7, 85, 2, 2,
	701, 703, 5, 46, 24, 2, 702, 700, 3, 2, 2, 2, 703, 706, 3, 2, 2, 2, 704,
	702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 708, 3, 2, 2, 2, 706, 704,
	3, 2, 2, 2, 707, 709, 7, 85, 2, 2, 708, 707, 3, 2, 2, 2, 708, 709, 3, 2,
	2, 2, 709, 711, 3, 2, 2, 2, 710, 699, 3, 2, 2, 2, 710, 711, 3, 2, 2, 2,
	711, 712, 3, 2, 2, 2, 712, 771, 7, 91, 2, 2, 713, 714, 7, 90, 2, 2, 714,
	715, 5, 24, 13, 2, 715, 716, 7, 87, 2, 2, 716, 717, 5, 24, 13, 2, 717,
	720, 7, 5, 2, 2, 718, 719, 7, 107, 2, 2, 719, 721, 7, 85, 2, 2, 720, 718,
	3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 723, 7, 107,
	2, 2, 723, 724, 7, 6, 2, 2, 724, 727, 5, 24, 13, 2, 725, 726, 9, 2, 2,
	2, 726, 728, 5, 24, 13, 2, 727, 725, 3, 2, 2, 2, 727, 728, 3, 2, 2, 2,
	728, 731, 3, 2, 2, 2, 729, 730, 7, 7, 2, 2, 730, 732, 5, 24, 13, 2, 731,
	729, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 734,
	7, 91, 2, 2, 734, 771, 3, 2, 2, 2, 735, 747, 7, 92, 2, 2, 736, 741, 5,
	44, 23, 2, 737, 738, 7, 85, 2, 2, 738, 740, 5, 44, 23, 2, 739, 737, 3,
	2, 2, 2, 740, 743, 3, 2, 2, 2, 741, 739, 3, 2, 2, 2, 741, 742, 3, 2, 2,
	2, 742, 745, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 744, 746, 7, 85, 2, 2, 745,
	744, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 746, 748, 3, 2, 2, 2, 747, 736,
	3, 2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 749, 3, 2, 2, 2, 749, 771, 7, 93,
	2, 2, 750, 751, 7, 92, 2, 2, 751, 752, 5, 24, 13, 2, 752, 755, 7, 5, 2,
	2, 753, 754, 7, 107, 2, 2, 754, 756, 7, 85, 2, 2, 755, 753, 3, 2, 2, 2,
	755, 756, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757, 758, 7, 107, 2, 2, 758,
	759, 7, 6, 2, 2, 759, 762, 5, 24, 13, 2, 760, 761, 9, 2, 2, 2, 761, 763,
	5, 24, 13, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2, 763, 766, 3,
	2, 2, 2, 764, 765, 7, 7, 2, 2, 765, 767, 5, 24, 13, 2, 766, 764, 3, 2,
	2, 2, 766, 767, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 769, 7, 93, 2, 2,
	769, 771, 3, 2, 2, 2, 770, 612, 3, 2, 2, 2, 770, 613, 3, 2, 2, 2, 770,
	614, 3, 2, 2, 2, 770, 615, 3, 2, 2, 2, 770, 616, 3, 2, 2, 2, 770, 617,
	3, 2, 2, 2, 770, 618, 3, 2, 2, 2, 770, 619, 3, 2, 2, 2, 770, 620, 3, 2,
	2, 2, 770, 667, 3, 2, 2, 2, 770, 694, 3, 2, 2, 2, 770, 698, 3, 2, 2, 2,
	770, 713, 3, 2, 2, 2, 770, 735, 3, 2, 2, 2, 770, 750, 3, 2, 2, 2, 771,
	43, 3, 2, 2, 2, 772, 774, 7, 51, 2, 2, 773, 772, 3, 2, 2, 2, 773, 774,
	3, 2, 2, 2, 774, 775, 3, 2, 2, 2, 775, 778, 5, 24, 13, 2, 776, 777, 7,
	7, 2, 2, 777, 779, 5, 24, 13, 2, 778, 776, 3, 2, 2, 2, 778, 779, 3, 2,
	2, 2, 779, 45, 3, 2, 2, 2, 780, 784, 5, 48, 25, 2, 781, 782, 7, 51, 2,
	2, 782, 784, 5, 24, 13, 2, 783, 780, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2,
	784, 47, 3, 2, 2, 2, 785, 786, 7, 107, 2, 2, 786, 787, 7, 87, 2, 2, 787,
	828, 5, 24, 13, 2, 788, 789, 5, 50, 26, 2, 789, 790, 7, 87, 2, 2, 790,
	791, 5, 24, 13, 2, 791, 828, 3, 2, 2, 2, 792, 793, 7, 92, 2, 2, 793, 794,
	5, 24, 13, 2, 794, 795, 7, 93, 2, 2, 795, 796, 7, 87, 2, 2, 796, 797, 5,
	24, 13, 2, 797, 828, 3, 2, 2, 2, 798, 799, 7, 107, 2, 2, 799, 818, 7, 88,
	2, 2, 800, 805, 7, 107, 2, 2, 801, 802, 7, 85, 2, 2, 802, 804, 7, 107,
	2, 2, 803, 801, 3, 2, 2, 2, 804, 807, 3, 2, 2, 2, 805, 803, 3, 2, 2, 2,
	805, 806, 3, 2, 2, 2, 806, 811, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 808,
	809, 7, 85, 2, 2, 809, 810, 7, 51, 2, 2, 810, 812, 7, 107, 2, 2, 811, 808,
	3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 814, 3, 2, 2, 2, 813, 815, 7, 85,
	2, 2, 814, 813, 3, 2, 2, 2, 814, 815, 3, 2, 2, 2, 815, 819, 3, 2, 2, 2,
	816, 817, 7, 51, 2, 2, 817, 819, 7, 107, 2, 2, 818, 800, 3, 2, 2, 2, 818,
	816, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 821,
	7, 89, 2, 2, 821, 828, 5, 8, 5, 2, 822, 828, 7, 107, 2, 2, 823, 824, 7,
	92, 2, 2, 824, 825, 5, 24, 13, 2, 825, 826, 7, 93, 2, 2, 826, 828, 3, 2,
	2, 2, 827, 785, 3, 2, 2, 2, 827, 788, 3, 2, 2, 2, 827, 792, 3, 2, 2, 2,
	827, 798, 3, 2, 2, 2, 827, 822, 3, 2, 2, 2, 827, 823, 3, 2, 2, 2, 828,
	49, 3, 2, 2, 2, 829, 833, 7, 49, 2, 2, 830, 833, 7, 50, 2, 2, 831, 833,
	5, 52, 27, 2, 832, 829, 3, 2, 2, 2, 832, 830, 3, 2, 2, 2, 832, 831, 3,
	2, 2, 2, 833, 51, 3, 2, 2, 2, 834, 838, 7, 106, 2, 2, 835, 837, 5, 54,
	28, 2, 836, 835, 3, 2, 2, 2, 837, 840, 3, 2, 2, 2, 838, 836, 3, 2, 2, 2,
	838, 839, 3, 2, 2, 2, 839, 841, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 841,
	842, 7, 106, 2, 2, 842, 53, 3, 2, 2, 2, 843, 850, 7, 108, 2, 2, 844, 850,
	7, 110, 2, 2, 845, 846, 7, 109, 2, 2, 846, 847, 5, 24, 13, 2, 847, 848,
	7, 91, 2, 2, 848, 850, 3, 2, 2, 2, 849, 843, 3, 2, 2, 2, 849, 844, 3, 2,
	2, 2, 849, 845, 3, 2, 2, 2, 850, 55, 3, 2, 2, 2, 111, 58, 64, 68, 88, 94,
	97, 102, 104, 109, 117, 121, 127, 133, 145, 150, 157, 163, 172, 180, 184,
	196, 201, 209, 212, 219, 236, 242, 245, 249, 256, 271, 275, 281, 284, 292,
	297, 302, 307, 313, 318, 325, 356, 361, 374, 379, 397, 453, 467, 471, 476,
	478, 486, 490, 494, 498, 506, 510, 512, 517, 525, 532, 534, 549, 555, 558,
	569, 578, 590, 600, 602, 610, 627, 633, 636, 640, 650, 656, 659, 663, 667,
	677, 683, 686, 690, 694, 704, 708, 710, 720, 727, 731, 741, 745, 747, 755,
	762, 766, 770, 773, 778, 783, 805, 811, 814, 818, 827, 832, 838, 849,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'true'", "'false'", "'for'", "'in'", "'if'", "'while'", "'do'", "'break'",
	"'continue'", "'func'", "'when'", "'else'", "'nil'", "'undefined'", "",
	"'return'", "'export'", "'class'", "'defer'", "'blockDefer'", "'throw'",
	"'try'", "'catch'", "'finally'", "'static'", "'assert'", "'extend'", "'use@'",
	"'use'", "'switch'", "'case'", "'fallthrough'", "'default'", "'is'", "",
	"", "", "", "'0'", "", "", "", "", "", "", "", "", "", "'...'", "'->'",
	"'=>'", "'**'", "'++'", "'--'", "'=='", "'!='", "'>='", "'<='", "':='",
	"'+='", "'-='", "'*='", "'/='", "'%='", "'&&'", "'||'", "'?.'", "'??'",
	"'&'", "'|'", "'~'", "'<<'", "'>>'", "'^'", "'&='", "'|='", "'<<='", "'>>='",
	"'^='", "'..<'", "'..'", "'.'", "','", "';'", "':'", "'('", "')'", "'{'",
	"'}'", "'['", "']'", "'!'", "'?'", "'>'", "'<'", "'='", "'+'", "'-'", "'*'",
	"'/'", "'%'", "'@'", "'@@'", "'''", "", "", "'${'",
}
var symbolicNames = []string{
	"", "TRUE", "FALSE", "FOR", "IN", "IF", "WHILE", "DO", "BREAK", "CONTINUE",
	"FUNC", "WHEN", "ELSE", "NIL", "UNDEFINED", "RETURN_NONE", "RETURN", "EXPORT",
	"CLASS", "DEFER", "BLOCK_DEFER", "THROW", "TRY", "CATCH", "FINALLY", "STATIC",
	"ASSERT", "EXTEND", "USE_AT", "USE", "SWITCH", "CASE", "FALLTHROUGH", "DEFAULT",
	"IS", "WS", "LINECOMMENT", "LINECOMMENT2", "BLOCKCOMMENT", "INT_ZERO",
	"INT_DEC", "INT_HEX", "INT_OCT", "INT_BIN", "BIGNUM", "FLOAT", "ENUM",
	"STRING", "RSTRING", "MORE_ARGS", "LEAD_TO", "ARROW", "POW", "PLUS_PLUS",
	"MINUS_MINUS", "EQUAL", "NOT_EQUAL", "GTEQ", "LTEQ", "LOCAL_ASSIGN", "PLUS_ASSIGN",
	"MINUS_ASSIGN", "TIMES_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "LOGIC_AND",
	"LOGIC_OR", "OPTIONAL_CALL", "OPTIONAL_ELSE", "BIT_AND", "BIT_OR", "BIT_NOT",
	"BIT_SHL", "BIT_SHR", "BIT_XOR", "BIT_AND_ASSIGN", "BIT_OR_ASSIGN", "BIT_SHL_ASSIGN",
	"BIT_SHR_ASSIGN", "BIT_XOR_ASSIGN", "RANGE_WITHOUT_END", "RANGE_WITH_END",
	"DOT", "COMMA", "SEMICOLON", "COLON", "L_PAREN", "R_PAREN", "L_CURLY",
	"R_CURLY", "L_BRACKET", "R_BRACKET", "LOGIC_NOT", "QUESTION", "GT", "LT",
	"ASSIGN", "PLUS", "MINUS", "TIMES", "DIV", "MOD", "SINGLE_AT", "DOUBLE_AT",
	"QUOTE", "IDENTIFIER", "TS_RAW", "TS_EXPR_START", "TS_IDENTIFIER", "StrExpr_WS",
}

var ruleNames = []string{
	"replItem", "module", "block", "codeBlock", "stmt", "ifCondition", "memberDef",
	"callStmt", "switchCase", "switchDefault", "comparator", "expr", "whenCondition",
	"arguments", "funcArgument", "assignExpr", "preIncDec", "postIncDec", "lval",
	"integer", "literal", "arrayItem", "objItem", "keyValue", "stringLiteral",
	"templateString", "tsItem",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ZggParser struct {
	ZggBaseParser
}

func NewZggParser(input antlr.TokenStream) *ZggParser {
	this := new(ZggParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ZggParser.g4"

	return this
}

// ZggParser tokens.
const (
	ZggParserEOF               = antlr.TokenEOF
	ZggParserTRUE              = 1
	ZggParserFALSE             = 2
	ZggParserFOR               = 3
	ZggParserIN                = 4
	ZggParserIF                = 5
	ZggParserWHILE             = 6
	ZggParserDO                = 7
	ZggParserBREAK             = 8
	ZggParserCONTINUE          = 9
	ZggParserFUNC              = 10
	ZggParserWHEN              = 11
	ZggParserELSE              = 12
	ZggParserNIL               = 13
	ZggParserUNDEFINED         = 14
	ZggParserRETURN_NONE       = 15
	ZggParserRETURN            = 16
	ZggParserEXPORT            = 17
	ZggParserCLASS             = 18
	ZggParserDEFER             = 19
	ZggParserBLOCK_DEFER       = 20
	ZggParserTHROW             = 21
	ZggParserTRY               = 22
	ZggParserCATCH             = 23
	ZggParserFINALLY           = 24
	ZggParserSTATIC            = 25
	ZggParserASSERT            = 26
	ZggParserEXTEND            = 27
	ZggParserUSE_AT            = 28
	ZggParserUSE               = 29
	ZggParserSWITCH            = 30
	ZggParserCASE              = 31
	ZggParserFALLTHROUGH       = 32
	ZggParserDEFAULT           = 33
	ZggParserIS                = 34
	ZggParserWS                = 35
	ZggParserLINECOMMENT       = 36
	ZggParserLINECOMMENT2      = 37
	ZggParserBLOCKCOMMENT      = 38
	ZggParserINT_ZERO          = 39
	ZggParserINT_DEC           = 40
	ZggParserINT_HEX           = 41
	ZggParserINT_OCT           = 42
	ZggParserINT_BIN           = 43
	ZggParserBIGNUM            = 44
	ZggParserFLOAT             = 45
	ZggParserENUM              = 46
	ZggParserSTRING            = 47
	ZggParserRSTRING           = 48
	ZggParserMORE_ARGS         = 49
	ZggParserLEAD_TO           = 50
	ZggParserARROW             = 51
	ZggParserPOW               = 52
	ZggParserPLUS_PLUS         = 53
	ZggParserMINUS_MINUS       = 54
	ZggParserEQUAL             = 55
	ZggParserNOT_EQUAL         = 56
	ZggParserGTEQ              = 57
	ZggParserLTEQ              = 58
	ZggParserLOCAL_ASSIGN      = 59
	ZggParserPLUS_ASSIGN       = 60
	ZggParserMINUS_ASSIGN      = 61
	ZggParserTIMES_ASSIGN      = 62
	ZggParserDIV_ASSIGN        = 63
	ZggParserMOD_ASSIGN        = 64
	ZggParserLOGIC_AND         = 65
	ZggParserLOGIC_OR          = 66
	ZggParserOPTIONAL_CALL     = 67
	ZggParserOPTIONAL_ELSE     = 68
	ZggParserBIT_AND           = 69
	ZggParserBIT_OR            = 70
	ZggParserBIT_NOT           = 71
	ZggParserBIT_SHL           = 72
	ZggParserBIT_SHR           = 73
	ZggParserBIT_XOR           = 74
	ZggParserBIT_AND_ASSIGN    = 75
	ZggParserBIT_OR_ASSIGN     = 76
	ZggParserBIT_SHL_ASSIGN    = 77
	ZggParserBIT_SHR_ASSIGN    = 78
	ZggParserBIT_XOR_ASSIGN    = 79
	ZggParserRANGE_WITHOUT_END = 80
	ZggParserRANGE_WITH_END    = 81
	ZggParserDOT               = 82
	ZggParserCOMMA             = 83
	ZggParserSEMICOLON         = 84
	ZggParserCOLON             = 85
	ZggParserL_PAREN           = 86
	ZggParserR_PAREN           = 87
	ZggParserL_CURLY           = 88
	ZggParserR_CURLY           = 89
	ZggParserL_BRACKET         = 90
	ZggParserR_BRACKET         = 91
	ZggParserLOGIC_NOT         = 92
	ZggParserQUESTION          = 93
	ZggParserGT                = 94
	ZggParserLT                = 95
	ZggParserASSIGN            = 96
	ZggParserPLUS              = 97
	ZggParserMINUS             = 98
	ZggParserTIMES             = 99
	ZggParserDIV               = 100
	ZggParserMOD               = 101
	ZggParserSINGLE_AT         = 102
	ZggParserDOUBLE_AT         = 103
	ZggParserQUOTE             = 104
	ZggParserIDENTIFIER        = 105
	ZggParserTS_RAW            = 106
	ZggParserTS_EXPR_START     = 107
	ZggParserTS_IDENTIFIER     = 108
	ZggParserStrExpr_WS        = 109
)

// ZggParser rules.
const (
	ZggParserRULE_replItem       = 0
	ZggParserRULE_module         = 1
	ZggParserRULE_block          = 2
	ZggParserRULE_codeBlock      = 3
	ZggParserRULE_stmt           = 4
	ZggParserRULE_ifCondition    = 5
	ZggParserRULE_memberDef      = 6
	ZggParserRULE_callStmt       = 7
	ZggParserRULE_switchCase     = 8
	ZggParserRULE_switchDefault  = 9
	ZggParserRULE_comparator     = 10
	ZggParserRULE_expr           = 11
	ZggParserRULE_whenCondition  = 12
	ZggParserRULE_arguments      = 13
	ZggParserRULE_funcArgument   = 14
	ZggParserRULE_assignExpr     = 15
	ZggParserRULE_preIncDec      = 16
	ZggParserRULE_postIncDec     = 17
	ZggParserRULE_lval           = 18
	ZggParserRULE_integer        = 19
	ZggParserRULE_literal        = 20
	ZggParserRULE_arrayItem      = 21
	ZggParserRULE_objItem        = 22
	ZggParserRULE_keyValue       = 23
	ZggParserRULE_stringLiteral  = 24
	ZggParserRULE_templateString = 25
	ZggParserRULE_tsItem         = 26
)

// IReplItemContext is an interface to support dynamic dispatch.
type IReplItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReplItemContext differentiates from other interfaces.
	IsReplItemContext()
}

type ReplItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplItemContext() *ReplItemContext {
	var p = new(ReplItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_replItem
	return p
}

func (*ReplItemContext) IsReplItemContext() {}

func NewReplItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplItemContext {
	var p = new(ReplItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_replItem

	return p
}

func (s *ReplItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplItemContext) CopyFrom(ctx *ReplItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ReplItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplBlockContext struct {
	*ReplItemContext
}

func NewReplBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplBlockContext {
	var p = new(ReplBlockContext)

	p.ReplItemContext = NewEmptyReplItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplItemContext))

	return p
}

func (s *ReplBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ReplBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitReplBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReplExprContext struct {
	*ReplItemContext
}

func NewReplExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplExprContext {
	var p = new(ReplExprContext)

	p.ReplItemContext = NewEmptyReplItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplItemContext))

	return p
}

func (s *ReplExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReplExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitReplExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ReplItem() (localctx IReplItemContext) {
	localctx = NewReplItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ZggParserRULE_replItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(56)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReplExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(54)
			p.expr(0)
		}

	case 2:
		localctx = NewReplBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(55)
			p.Block()
		}

	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ZggParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(58)
		p.Block()
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ZggParserSEMICOLON)
}

func (s *BlockContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ZggParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(66)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFOR)|(1<<ZggParserIF)|(1<<ZggParserWHILE)|(1<<ZggParserDO)|(1<<ZggParserBREAK)|(1<<ZggParserCONTINUE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserRETURN_NONE)|(1<<ZggParserRETURN)|(1<<ZggParserEXPORT)|(1<<ZggParserCLASS)|(1<<ZggParserDEFER)|(1<<ZggParserBLOCK_DEFER)|(1<<ZggParserTRY)|(1<<ZggParserASSERT)|(1<<ZggParserEXTEND)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE)|(1<<ZggParserSWITCH))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
		{
			p.SetState(60)
			p.Stmt()
		}
		p.SetState(62)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserSEMICOLON {
			{
				p.SetState(61)
				p.Match(ZggParserSEMICOLON)
			}

		}

		p.SetState(68)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_codeBlock
	return p
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *CodeBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CodeBlockContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ZggParserRULE_codeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(69)
		p.Match(ZggParserL_CURLY)
	}
	{
		p.SetState(70)
		p.Block()
	}
	{
		p.SetState(71)
		p.Match(ZggParserR_CURLY)
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyFrom(ctx *StmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StmtExtendContext struct {
	*StmtContext
}

func NewStmtExtendContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExtendContext {
	var p = new(StmtExtendContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExtendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExtendContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(ZggParserEXTEND, 0)
}

func (s *StmtExtendContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtExtendContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtExtendContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtExtendContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExtendContext) AllKeyValue() []IKeyValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyValueContext)(nil)).Elem())
	var tst = make([]IKeyValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyValueContext)
		}
	}

	return tst
}

func (s *StmtExtendContext) KeyValue(i int) IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *StmtExtendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExtend(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBreakContext struct {
	*StmtContext
	label antlr.Token
}

func NewStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBreakContext {
	var p = new(StmtBreakContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtBreakContext) GetLabel() antlr.Token { return s.label }

func (s *StmtBreakContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBreakContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ZggParserBREAK, 0)
}

func (s *StmtBreakContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDoWhileContext struct {
	*StmtContext
	label     antlr.Token
	execBlock ICodeBlockContext
	checkExpr IExprContext
}

func NewStmtDoWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDoWhileContext {
	var p = new(StmtDoWhileContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtDoWhileContext) GetLabel() antlr.Token { return s.label }

func (s *StmtDoWhileContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtDoWhileContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtDoWhileContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtDoWhileContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtDoWhileContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtDoWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDoWhileContext) DO() antlr.TerminalNode {
	return s.GetToken(ZggParserDO, 0)
}

func (s *StmtDoWhileContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ZggParserWHILE, 0)
}

func (s *StmtDoWhileContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtDoWhileContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtDoWhileContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtDoWhileContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtDoWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtDoWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtAssertContext struct {
	*StmtContext
}

func NewStmtAssertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtAssertContext {
	var p = new(StmtAssertContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtAssertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtAssertContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(ZggParserASSERT, 0)
}

func (s *StmtAssertContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtAssertContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtAssertContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtAssertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtAssert(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtTryContext struct {
	*StmtContext
	tryBlock     ICodeBlockContext
	excName      antlr.Token
	catchBlock   ICodeBlockContext
	finallyBlock ICodeBlockContext
}

func NewStmtTryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtTryContext {
	var p = new(StmtTryContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtTryContext) GetExcName() antlr.Token { return s.excName }

func (s *StmtTryContext) SetExcName(v antlr.Token) { s.excName = v }

func (s *StmtTryContext) GetTryBlock() ICodeBlockContext { return s.tryBlock }

func (s *StmtTryContext) GetCatchBlock() ICodeBlockContext { return s.catchBlock }

func (s *StmtTryContext) GetFinallyBlock() ICodeBlockContext { return s.finallyBlock }

func (s *StmtTryContext) SetTryBlock(v ICodeBlockContext) { s.tryBlock = v }

func (s *StmtTryContext) SetCatchBlock(v ICodeBlockContext) { s.catchBlock = v }

func (s *StmtTryContext) SetFinallyBlock(v ICodeBlockContext) { s.finallyBlock = v }

func (s *StmtTryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtTryContext) TRY() antlr.TerminalNode {
	return s.GetToken(ZggParserTRY, 0)
}

func (s *StmtTryContext) AllCodeBlock() []ICodeBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem())
	var tst = make([]ICodeBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICodeBlockContext)
		}
	}

	return tst
}

func (s *StmtTryContext) CodeBlock(i int) ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtTryContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ZggParserCATCH, 0)
}

func (s *StmtTryContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtTryContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtTryContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ZggParserFINALLY, 0)
}

func (s *StmtTryContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtTryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtTry(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtContinueContext struct {
	*StmtContext
	label antlr.Token
}

func NewStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtContinueContext {
	var p = new(StmtContinueContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtContinueContext) GetLabel() antlr.Token { return s.label }

func (s *StmtContinueContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContinueContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ZggParserCONTINUE, 0)
}

func (s *StmtContinueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtSwitchContext struct {
	*StmtContext
	testValue IExprContext
}

func NewStmtSwitchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtSwitchContext {
	var p = new(StmtSwitchContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtSwitchContext) GetTestValue() IExprContext { return s.testValue }

func (s *StmtSwitchContext) SetTestValue(v IExprContext) { s.testValue = v }

func (s *StmtSwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtSwitchContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ZggParserSWITCH, 0)
}

func (s *StmtSwitchContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtSwitchContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtSwitchContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtSwitchContext) AllSwitchCase() []ISwitchCaseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem())
	var tst = make([]ISwitchCaseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchCaseContext)
		}
	}

	return tst
}

func (s *StmtSwitchContext) SwitchCase(i int) ISwitchCaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseContext)
}

func (s *StmtSwitchContext) SwitchDefault() ISwitchDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchDefaultContext)
}

func (s *StmtSwitchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtSwitch(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtPreIncDecContext struct {
	*StmtContext
}

func NewStmtPreIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtPreIncDecContext {
	var p = new(StmtPreIncDecContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtPreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtPreIncDecContext) PreIncDec() IPreIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncDecContext)
}

func (s *StmtPreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtClassDefineContext struct {
	*StmtContext
	className antlr.Token
	_expr     IExprContext
	baseCls   []IExprContext
}

func NewStmtClassDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtClassDefineContext {
	var p = new(StmtClassDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtClassDefineContext) GetClassName() antlr.Token { return s.className }

func (s *StmtClassDefineContext) SetClassName(v antlr.Token) { s.className = v }

func (s *StmtClassDefineContext) Get_expr() IExprContext { return s._expr }

func (s *StmtClassDefineContext) Set_expr(v IExprContext) { s._expr = v }

func (s *StmtClassDefineContext) GetBaseCls() []IExprContext { return s.baseCls }

func (s *StmtClassDefineContext) SetBaseCls(v []IExprContext) { s.baseCls = v }

func (s *StmtClassDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtClassDefineContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ZggParserCLASS, 0)
}

func (s *StmtClassDefineContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtClassDefineContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtClassDefineContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtClassDefineContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtClassDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtClassDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtClassDefineContext) AllMemberDef() []IMemberDefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberDefContext)(nil)).Elem())
	var tst = make([]IMemberDefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberDefContext)
		}
	}

	return tst
}

func (s *StmtClassDefineContext) MemberDef(i int) IMemberDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberDefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberDefContext)
}

func (s *StmtClassDefineContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtClassDefineContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtClassDefineContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtClassDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtClassDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDeferBlockContext struct {
	*StmtContext
}

func NewStmtDeferBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDeferBlockContext {
	var p = new(StmtDeferBlockContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtDeferBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDeferBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtDeferBlockContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserDEFER, 0)
}

func (s *StmtDeferBlockContext) BLOCK_DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserBLOCK_DEFER, 0)
}

func (s *StmtDeferBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtDeferBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtIfContext struct {
	*StmtContext
}

func NewStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtIfContext {
	var p = new(StmtIfContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtIfContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIF)
}

func (s *StmtIfContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIF, i)
}

func (s *StmtIfContext) AllIfCondition() []IIfConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIfConditionContext)(nil)).Elem())
	var tst = make([]IIfConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIfConditionContext)
		}
	}

	return tst
}

func (s *StmtIfContext) IfCondition(i int) IIfConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIfConditionContext)
}

func (s *StmtIfContext) AllCodeBlock() []ICodeBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem())
	var tst = make([]ICodeBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICodeBlockContext)
		}
	}

	return tst
}

func (s *StmtIfContext) CodeBlock(i int) ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtIfContext) AllELSE() []antlr.TerminalNode {
	return s.GetTokens(ZggParserELSE)
}

func (s *StmtIfContext) ELSE(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, i)
}

func (s *StmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtFuncCallContext struct {
	*StmtContext
}

func NewStmtFuncCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtFuncCallContext {
	var p = new(StmtFuncCallContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtFuncCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtFuncCallContext) CallStmt() ICallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallStmtContext)
}

func (s *StmtFuncCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFuncCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDeferContext struct {
	*StmtContext
}

func NewStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDeferContext {
	var p = new(StmtDeferContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDeferContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtDeferContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *StmtDeferContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserDEFER, 0)
}

func (s *StmtDeferContext) BLOCK_DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserBLOCK_DEFER, 0)
}

func (s *StmtDeferContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *StmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportFuncDefineContext struct {
	*StmtContext
}

func NewStmtExportFuncDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportFuncDefineContext {
	var p = new(StmtExportFuncDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportFuncDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportFuncDefineContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportFuncDefineContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *StmtExportFuncDefineContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtExportFuncDefineContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtExportFuncDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtExportFuncDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtExportFuncDefineContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtExportFuncDefineContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *StmtExportFuncDefineContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *StmtExportFuncDefineContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *StmtExportFuncDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportFuncDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBlockContext struct {
	*StmtContext
}

func NewStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBlockContext {
	var p = new(StmtBlockContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportIdentifierContext struct {
	*StmtContext
}

func NewStmtExportIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportIdentifierContext {
	var p = new(StmtExportIdentifierContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportIdentifierContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtExportIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtWhileContext struct {
	*StmtContext
	label     antlr.Token
	checkExpr IExprContext
	execBlock ICodeBlockContext
}

func NewStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtWhileContext {
	var p = new(StmtWhileContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtWhileContext) GetLabel() antlr.Token { return s.label }

func (s *StmtWhileContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtWhileContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtWhileContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtWhileContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtWhileContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtWhileContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ZggParserWHILE, 0)
}

func (s *StmtWhileContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtWhileContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtWhileContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtWhileContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtFuncDefineContext struct {
	*StmtContext
}

func NewStmtFuncDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtFuncDefineContext {
	var p = new(StmtFuncDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtFuncDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtFuncDefineContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *StmtFuncDefineContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtFuncDefineContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtFuncDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtFuncDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtFuncDefineContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtFuncDefineContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *StmtFuncDefineContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *StmtFuncDefineContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *StmtFuncDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFuncDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtForContext struct {
	*StmtContext
	label     antlr.Token
	initExpr  IExprContext
	checkExpr IExprContext
	nextExpr  IExprContext
	execBlock ICodeBlockContext
}

func NewStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtForContext {
	var p = new(StmtForContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtForContext) GetLabel() antlr.Token { return s.label }

func (s *StmtForContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtForContext) GetInitExpr() IExprContext { return s.initExpr }

func (s *StmtForContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtForContext) GetNextExpr() IExprContext { return s.nextExpr }

func (s *StmtForContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtForContext) SetInitExpr(v IExprContext) { s.initExpr = v }

func (s *StmtForContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtForContext) SetNextExpr(v IExprContext) { s.nextExpr = v }

func (s *StmtForContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtForContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *StmtForContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ZggParserSEMICOLON)
}

func (s *StmtForContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, i)
}

func (s *StmtForContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtForContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtForContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtForContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtForContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtForEachContext struct {
	*StmtContext
	label     antlr.Token
	idIndex   antlr.Token
	idValue   antlr.Token
	begin     IExprContext
	end       IExprContext
	execBlock ICodeBlockContext
}

func NewStmtForEachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtForEachContext {
	var p = new(StmtForEachContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtForEachContext) GetLabel() antlr.Token { return s.label }

func (s *StmtForEachContext) GetIdIndex() antlr.Token { return s.idIndex }

func (s *StmtForEachContext) GetIdValue() antlr.Token { return s.idValue }

func (s *StmtForEachContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtForEachContext) SetIdIndex(v antlr.Token) { s.idIndex = v }

func (s *StmtForEachContext) SetIdValue(v antlr.Token) { s.idValue = v }

func (s *StmtForEachContext) GetBegin() IExprContext { return s.begin }

func (s *StmtForEachContext) GetEnd() IExprContext { return s.end }

func (s *StmtForEachContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtForEachContext) SetBegin(v IExprContext) { s.begin = v }

func (s *StmtForEachContext) SetEnd(v IExprContext) { s.end = v }

func (s *StmtForEachContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtForEachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtForEachContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *StmtForEachContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *StmtForEachContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtForEachContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtForEachContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtForEachContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtForEachContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtForEachContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtForEachContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtForEachContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *StmtForEachContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *StmtForEachContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtForEach(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtReturnNoneContext struct {
	*StmtContext
}

func NewStmtReturnNoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtReturnNoneContext {
	var p = new(StmtReturnNoneContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtReturnNoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtReturnNoneContext) RETURN_NONE() antlr.TerminalNode {
	return s.GetToken(ZggParserRETURN_NONE, 0)
}

func (s *StmtReturnNoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtReturnNone(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportExprContext struct {
	*StmtContext
}

func NewStmtExportExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportExprContext {
	var p = new(StmtExportExprContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportExprContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtExportExprContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *StmtExportExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtExportExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtReturnContext struct {
	*StmtContext
}

func NewStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtReturnContext {
	var p = new(StmtReturnContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ZggParserRETURN, 0)
}

func (s *StmtReturnContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtPostIncDecContext struct {
	*StmtContext
}

func NewStmtPostIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtPostIncDecContext {
	var p = new(StmtPostIncDecContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtPostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtPostIncDecContext) PostIncDec() IPostIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostIncDecContext)
}

func (s *StmtPostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtAssignContext struct {
	*StmtContext
}

func NewStmtAssignContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtAssignContext {
	var p = new(StmtAssignContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtAssignContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *StmtAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ZggParserRULE_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(73)
			p.CodeBlock()
		}

	case 2:
		localctx = NewStmtPreIncDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(74)
			p.PreIncDec()
		}

	case 3:
		localctx = NewStmtPostIncDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(75)
			p.PostIncDec()
		}

	case 4:
		localctx = NewStmtAssignContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(76)
			p.AssignExpr()
		}

	case 5:
		localctx = NewStmtFuncCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(77)
			p.CallStmt()
		}

	case 6:
		localctx = NewStmtFuncDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(78)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(79)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(80)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(102)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(81)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(86)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(82)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(83)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(88)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
			}
			p.SetState(92)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(89)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(90)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(91)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(95)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(94)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(97)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(98)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(100)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(99)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(104)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(105)
			p.CodeBlock()
		}

	case 7:
		localctx = NewStmtClassDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserEXPORT {
			{
				p.SetState(106)
				p.Match(ZggParserEXPORT)
			}

		}
		{
			p.SetState(109)
			p.Match(ZggParserCLASS)
		}
		{
			p.SetState(110)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*StmtClassDefineContext).className = _m
		}
		p.SetState(119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserL_PAREN {
			{
				p.SetState(111)
				p.Match(ZggParserL_PAREN)
			}
			{
				p.SetState(112)

				var _x = p.expr(0)

				localctx.(*StmtClassDefineContext)._expr = _x
			}
			localctx.(*StmtClassDefineContext).baseCls = append(localctx.(*StmtClassDefineContext).baseCls, localctx.(*StmtClassDefineContext)._expr)
			p.SetState(115)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(113)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(114)

					var _x = p.expr(0)

					localctx.(*StmtClassDefineContext)._expr = _x
				}
				localctx.(*StmtClassDefineContext).baseCls = append(localctx.(*StmtClassDefineContext).baseCls, localctx.(*StmtClassDefineContext)._expr)

			}
			{
				p.SetState(117)
				p.Match(ZggParserR_PAREN)
			}

		}
		{
			p.SetState(121)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ZggParserSTATIC-25))|(1<<(ZggParserSTRING-25))|(1<<(ZggParserRSTRING-25)))) != 0) || (((_la-90)&-(0x1f+1)) == 0 && ((1<<uint((_la-90)))&((1<<(ZggParserL_BRACKET-90))|(1<<(ZggParserQUOTE-90))|(1<<(ZggParserIDENTIFIER-90)))) != 0) {
			{
				p.SetState(122)
				p.MemberDef()
			}

			p.SetState(127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(128)
			p.Match(ZggParserR_CURLY)
		}

	case 8:
		localctx = NewStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(129)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForContext).label = _m
			}
			{
				p.SetState(130)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(133)
			p.Match(ZggParserFOR)
		}
		{
			p.SetState(134)

			var _x = p.expr(0)

			localctx.(*StmtForContext).initExpr = _x
		}
		{
			p.SetState(135)
			p.Match(ZggParserSEMICOLON)
		}
		{
			p.SetState(136)

			var _x = p.expr(0)

			localctx.(*StmtForContext).checkExpr = _x
		}
		{
			p.SetState(137)
			p.Match(ZggParserSEMICOLON)
		}
		{
			p.SetState(138)

			var _x = p.expr(0)

			localctx.(*StmtForContext).nextExpr = _x
		}
		{
			p.SetState(139)

			var _x = p.CodeBlock()

			localctx.(*StmtForContext).execBlock = _x
		}

	case 9:
		localctx = NewStmtForEachContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(141)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForEachContext).label = _m
			}
			{
				p.SetState(142)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(145)
			p.Match(ZggParserFOR)
		}
		p.SetState(148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(146)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForEachContext).idIndex = _m
			}
			{
				p.SetState(147)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(150)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*StmtForEachContext).idValue = _m
		}
		{
			p.SetState(151)
			p.Match(ZggParserIN)
		}
		{
			p.SetState(152)

			var _x = p.expr(0)

			localctx.(*StmtForEachContext).begin = _x
		}
		p.SetState(155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END {
			{
				p.SetState(153)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(154)

				var _x = p.expr(0)

				localctx.(*StmtForEachContext).end = _x
			}

		}
		{
			p.SetState(157)

			var _x = p.CodeBlock()

			localctx.(*StmtForEachContext).execBlock = _x
		}

	case 10:
		localctx = NewStmtDoWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(159)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtDoWhileContext).label = _m
			}
			{
				p.SetState(160)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(163)
			p.Match(ZggParserDO)
		}
		{
			p.SetState(164)

			var _x = p.CodeBlock()

			localctx.(*StmtDoWhileContext).execBlock = _x
		}
		{
			p.SetState(165)
			p.Match(ZggParserWHILE)
		}
		{
			p.SetState(166)

			var _x = p.expr(0)

			localctx.(*StmtDoWhileContext).checkExpr = _x
		}

	case 11:
		localctx = NewStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(168)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtWhileContext).label = _m
			}
			{
				p.SetState(169)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(172)
			p.Match(ZggParserWHILE)
		}
		{
			p.SetState(173)

			var _x = p.expr(0)

			localctx.(*StmtWhileContext).checkExpr = _x
		}
		{
			p.SetState(174)

			var _x = p.CodeBlock()

			localctx.(*StmtWhileContext).execBlock = _x
		}

	case 12:
		localctx = NewStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(176)
			p.Match(ZggParserCONTINUE)
		}
		p.SetState(178)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(177)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtContinueContext).label = _m
			}

		}

	case 13:
		localctx = NewStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(180)
			p.Match(ZggParserBREAK)
		}
		p.SetState(182)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(181)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtBreakContext).label = _m
			}

		}

	case 14:
		localctx = NewStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(184)
			p.Match(ZggParserIF)
		}
		{
			p.SetState(185)
			p.IfCondition()
		}
		{
			p.SetState(186)
			p.CodeBlock()
		}
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(187)
					p.Match(ZggParserELSE)
				}
				{
					p.SetState(188)
					p.Match(ZggParserIF)
				}
				{
					p.SetState(189)
					p.IfCondition()
				}
				{
					p.SetState(190)
					p.CodeBlock()
				}

			}
			p.SetState(196)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(197)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(198)
				p.CodeBlock()
			}

		}

	case 15:
		localctx = NewStmtSwitchContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(201)
			p.Match(ZggParserSWITCH)
		}
		{
			p.SetState(202)

			var _x = p.expr(0)

			localctx.(*StmtSwitchContext).testValue = _x
		}
		{
			p.SetState(203)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ZggParserCASE {
			{
				p.SetState(204)
				p.SwitchCase()
			}

			p.SetState(207)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserDEFAULT {
			{
				p.SetState(209)
				p.SwitchDefault()
			}

		}
		{
			p.SetState(212)
			p.Match(ZggParserR_CURLY)
		}

	case 16:
		localctx = NewStmtReturnNoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(214)
			p.Match(ZggParserRETURN_NONE)
		}

	case 17:
		localctx = NewStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(215)
			p.Match(ZggParserRETURN)
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(216)
				p.expr(0)
			}

		}

	case 18:
		localctx = NewStmtExportIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(219)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(220)
			p.Match(ZggParserIDENTIFIER)
		}

	case 19:
		localctx = NewStmtExportExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(221)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(222)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(223)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(224)
			p.expr(0)
		}

	case 20:
		localctx = NewStmtExportFuncDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(225)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(226)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(227)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(228)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(229)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(234)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(230)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(231)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(236)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
			}
			p.SetState(240)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(237)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(238)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(239)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(243)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(242)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(245)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(246)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(249)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(250)
			p.CodeBlock()
		}

	case 21:
		localctx = NewStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(251)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserDEFER || _la == ZggParserBLOCK_DEFER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(252)
			p.expr(0)
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserOPTIONAL_CALL {
			{
				p.SetState(253)
				p.Match(ZggParserOPTIONAL_CALL)
			}

		}
		{
			p.SetState(256)
			p.Arguments()
		}

	case 22:
		localctx = NewStmtDeferBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(258)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserDEFER || _la == ZggParserBLOCK_DEFER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(259)
			p.CodeBlock()
		}

	case 23:
		localctx = NewStmtTryContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(260)
			p.Match(ZggParserTRY)
		}
		{
			p.SetState(261)

			var _x = p.CodeBlock()

			localctx.(*StmtTryContext).tryBlock = _x
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserCATCH:
			{
				p.SetState(262)
				p.Match(ZggParserCATCH)
			}
			{
				p.SetState(263)
				p.Match(ZggParserL_PAREN)
			}
			{
				p.SetState(264)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtTryContext).excName = _m
			}
			{
				p.SetState(265)
				p.Match(ZggParserR_PAREN)
			}
			{
				p.SetState(266)

				var _x = p.CodeBlock()

				localctx.(*StmtTryContext).catchBlock = _x
			}
			p.SetState(269)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserFINALLY {
				{
					p.SetState(267)
					p.Match(ZggParserFINALLY)
				}
				{
					p.SetState(268)

					var _x = p.CodeBlock()

					localctx.(*StmtTryContext).finallyBlock = _x
				}

			}

		case ZggParserFINALLY:
			{
				p.SetState(271)
				p.Match(ZggParserFINALLY)
			}
			{
				p.SetState(272)

				var _x = p.CodeBlock()

				localctx.(*StmtTryContext).finallyBlock = _x
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 24:
		localctx = NewStmtAssertContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(275)
			p.Match(ZggParserASSERT)
		}
		{
			p.SetState(276)
			p.expr(0)
		}
		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(277)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(278)
				p.expr(0)
			}

		}

	case 25:
		localctx = NewStmtExtendContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		p.SetState(282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserEXPORT {
			{
				p.SetState(281)
				p.Match(ZggParserEXPORT)
			}

		}
		{
			p.SetState(284)
			p.Match(ZggParserEXTEND)
		}
		{
			p.SetState(285)
			p.expr(0)
		}
		{
			p.SetState(286)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserSTRING || _la == ZggParserRSTRING || (((_la-90)&-(0x1f+1)) == 0 && ((1<<uint((_la-90)))&((1<<(ZggParserL_BRACKET-90))|(1<<(ZggParserQUOTE-90))|(1<<(ZggParserIDENTIFIER-90)))) != 0) {
			{
				p.SetState(287)
				p.KeyValue()
			}

			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(293)
			p.Match(ZggParserR_CURLY)
		}

	}

	return localctx
}

// IIfConditionContext is an interface to support dynamic dispatch.
type IIfConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfConditionContext differentiates from other interfaces.
	IsIfConditionContext()
}

type IfConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionContext() *IfConditionContext {
	var p = new(IfConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_ifCondition
	return p
}

func (*IfConditionContext) IsIfConditionContext() {}

func NewIfConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionContext {
	var p = new(IfConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_ifCondition

	return p
}

func (s *IfConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfConditionContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *IfConditionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, 0)
}

func (s *IfConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIfCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) IfCondition() (localctx IIfConditionContext) {
	localctx = NewIfConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ZggParserRULE_ifCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(300)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(297)
			p.AssignExpr()
		}
		{
			p.SetState(298)
			p.Match(ZggParserSEMICOLON)
		}

	}
	{
		p.SetState(302)
		p.expr(0)
	}

	return localctx
}

// IMemberDefContext is an interface to support dynamic dispatch.
type IMemberDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberDefContext differentiates from other interfaces.
	IsMemberDefContext()
}

type MemberDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDefContext() *MemberDefContext {
	var p = new(MemberDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_memberDef
	return p
}

func (*MemberDefContext) IsMemberDefContext() {}

func NewMemberDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDefContext {
	var p = new(MemberDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_memberDef

	return p
}

func (s *MemberDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDefContext) KeyValue() IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *MemberDefContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ZggParserSTATIC, 0)
}

func (s *MemberDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitMemberDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) MemberDef() (localctx IMemberDefContext) {
	localctx = NewMemberDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ZggParserRULE_memberDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserSTATIC {
		{
			p.SetState(304)
			p.Match(ZggParserSTATIC)
		}

	}
	{
		p.SetState(307)
		p.KeyValue()
	}

	return localctx
}

// ICallStmtContext is an interface to support dynamic dispatch.
type ICallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStmtContext differentiates from other interfaces.
	IsCallStmtContext()
}

type CallStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStmtContext() *CallStmtContext {
	var p = new(CallStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_callStmt
	return p
}

func (*CallStmtContext) IsCallStmtContext() {}

func NewCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStmtContext {
	var p = new(CallStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_callStmt

	return p
}

func (s *CallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CallStmtContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *CallStmtContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *CallStmtContext) OPTIONAL_ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_ELSE, 0)
}

func (s *CallStmtContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitCallStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) CallStmt() (localctx ICallStmtContext) {
	localctx = NewCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ZggParserRULE_callStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.expr(0)
	}
	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserOPTIONAL_CALL {
		{
			p.SetState(310)
			p.Match(ZggParserOPTIONAL_CALL)
		}

	}
	{
		p.SetState(313)
		p.Arguments()
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserOPTIONAL_ELSE {
		{
			p.SetState(314)
			p.Match(ZggParserOPTIONAL_ELSE)
		}
		{
			p.SetState(315)
			p.CodeBlock()
		}

	}

	return localctx
}

// ISwitchCaseContext is an interface to support dynamic dispatch.
type ISwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchCaseContext differentiates from other interfaces.
	IsSwitchCaseContext()
}

type SwitchCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseContext() *SwitchCaseContext {
	var p = new(SwitchCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_switchCase
	return p
}

func (*SwitchCaseContext) IsSwitchCaseContext() {}

func NewSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseContext {
	var p = new(SwitchCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_switchCase

	return p
}

func (s *SwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ZggParserCASE, 0)
}

func (s *SwitchCaseContext) WhenCondition() IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *SwitchCaseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *SwitchCaseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchCaseContext) FALLTHROUGH() antlr.TerminalNode {
	return s.GetToken(ZggParserFALLTHROUGH, 0)
}

func (s *SwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) SwitchCase() (localctx ISwitchCaseContext) {
	localctx = NewSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ZggParserRULE_switchCase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(ZggParserCASE)
	}
	{
		p.SetState(319)
		p.WhenCondition()
	}
	{
		p.SetState(320)
		p.Match(ZggParserCOLON)
	}
	{
		p.SetState(321)
		p.Block()
	}
	p.SetState(323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserFALLTHROUGH {
		{
			p.SetState(322)
			p.Match(ZggParserFALLTHROUGH)
		}

	}

	return localctx
}

// ISwitchDefaultContext is an interface to support dynamic dispatch.
type ISwitchDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchDefaultContext differentiates from other interfaces.
	IsSwitchDefaultContext()
}

type SwitchDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchDefaultContext() *SwitchDefaultContext {
	var p = new(SwitchDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_switchDefault
	return p
}

func (*SwitchDefaultContext) IsSwitchDefaultContext() {}

func NewSwitchDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchDefaultContext {
	var p = new(SwitchDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_switchDefault

	return p
}

func (s *SwitchDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ZggParserDEFAULT, 0)
}

func (s *SwitchDefaultContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *SwitchDefaultContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitSwitchDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) SwitchDefault() (localctx ISwitchDefaultContext) {
	localctx = NewSwitchDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ZggParserRULE_switchDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.Match(ZggParserDEFAULT)
	}
	{
		p.SetState(326)
		p.Match(ZggParserCOLON)
	}
	{
		p.SetState(327)
		p.Block()
	}

	return localctx
}

// IComparatorContext is an interface to support dynamic dispatch.
type IComparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparatorContext differentiates from other interfaces.
	IsComparatorContext()
}

type ComparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparatorContext() *ComparatorContext {
	var p = new(ComparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_comparator
	return p
}

func (*ComparatorContext) IsComparatorContext() {}

func NewComparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparatorContext {
	var p = new(ComparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_comparator

	return p
}

func (s *ComparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ZggParserEQUAL, 0)
}

func (s *ComparatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(ZggParserNOT_EQUAL, 0)
}

func (s *ComparatorContext) GTEQ() antlr.TerminalNode {
	return s.GetToken(ZggParserGTEQ, 0)
}

func (s *ComparatorContext) LTEQ() antlr.TerminalNode {
	return s.GetToken(ZggParserLTEQ, 0)
}

func (s *ComparatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ZggParserLT, 0)
}

func (s *ComparatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ZggParserGT, 0)
}

func (s *ComparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitComparator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Comparator() (localctx IComparatorContext) {
	localctx = NewComparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ZggParserRULE_comparator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(ZggParserEQUAL-55))|(1<<(ZggParserNOT_EQUAL-55))|(1<<(ZggParserGTEQ-55))|(1<<(ZggParserLTEQ-55)))) != 0) || _la == ZggParserGT || _la == ZggParserLT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyFrom(ctx *ExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExprPlusMinusContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprPlusMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPlusMinusContext {
	var p = new(ExprPlusMinusContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPlusMinusContext) GetOp() antlr.Token { return s.op }

func (s *ExprPlusMinusContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprPlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPlusMinusContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprPlusMinusContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprPlusMinusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS, 0)
}

func (s *ExprPlusMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS, 0)
}

func (s *ExprPlusMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPlusMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseCloserContext struct {
	*ExprContext
}

func NewExprUseCloserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseCloserContext {
	var p = new(ExprUseCloserContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseCloserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseCloserContext) USE() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE, 0)
}

func (s *ExprUseCloserContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseCloserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseCloser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprInRangeContext struct {
	*ExprContext
}

func NewExprInRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprInRangeContext {
	var p = new(ExprInRangeContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprInRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprInRangeContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprInRangeContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprInRangeContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *ExprInRangeContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *ExprInRangeContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *ExprInRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprInRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAssignContext struct {
	*ExprContext
}

func NewExprAssignContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAssignContext {
	var p = new(ExprAssignContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAssignContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *ExprAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprInContainerContext struct {
	*ExprContext
}

func NewExprInContainerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprInContainerContext {
	var p = new(ExprInContainerContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprInContainerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprInContainerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprInContainerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprInContainerContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *ExprInContainerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprInContainer(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseMethodContext struct {
	*ExprContext
}

func NewExprUseMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseMethodContext {
	var p = new(ExprUseMethodContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseMethodContext) USE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE_AT, 0)
}

func (s *ExprUseMethodContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprUseMethodContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprWhenValueContext struct {
	*ExprContext
}

func NewExprWhenValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprWhenValueContext {
	var p = new(ExprWhenValueContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprWhenValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWhenValueContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ZggParserWHEN, 0)
}

func (s *ExprWhenValueContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprWhenValueContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWhenValueContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *ExprWhenValueContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *ExprWhenValueContext) AllWhenCondition() []IWhenConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem())
	var tst = make([]IWhenConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenConditionContext)
		}
	}

	return tst
}

func (s *ExprWhenValueContext) WhenCondition(i int) IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *ExprWhenValueContext) AllLEAD_TO() []antlr.TerminalNode {
	return s.GetTokens(ZggParserLEAD_TO)
}

func (s *ExprWhenValueContext) LEAD_TO(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserLEAD_TO, i)
}

func (s *ExprWhenValueContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, 0)
}

func (s *ExprWhenValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprWhenValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLiteralContext struct {
	*ExprContext
}

func NewExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLiteralContext {
	var p = new(ExprLiteralContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ExprLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprCompareContext struct {
	*ExprContext
}

func NewExprCompareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCompareContext {
	var p = new(ExprCompareContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCompareContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprCompareContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCompareContext) Comparator() IComparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparatorContext)
}

func (s *ExprCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprByFieldContext struct {
	*ExprContext
	field antlr.Token
}

func NewExprByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprByFieldContext {
	var p = new(ExprByFieldContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprByFieldContext) GetField() antlr.Token { return s.field }

func (s *ExprByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *ExprByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprByFieldContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *ExprByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprByField(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicOrContext struct {
	*ExprContext
}

func NewExprLogicOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicOrContext {
	var p = new(ExprLogicOrContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicOrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprLogicOrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicOrContext) LOGIC_OR() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_OR, 0)
}

func (s *ExprLogicOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitXorContext struct {
	*ExprContext
}

func NewExprBitXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitXorContext {
	var p = new(ExprBitXorContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitXorContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitXorContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitXorContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_XOR, 0)
}

func (s *ExprBitXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitXor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPreIncDecContext struct {
	*ExprContext
}

func NewExprPreIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPreIncDecContext {
	var p = new(ExprPreIncDecContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPreIncDecContext) PreIncDec() IPreIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncDecContext)
}

func (s *ExprPreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseBlockContext struct {
	*ExprContext
}

func NewExprUseBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseBlockContext {
	var p = new(ExprUseBlockContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseBlockContext) USE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE_AT, 0)
}

func (s *ExprUseBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ExprUseBlockContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPowContext struct {
	*ExprContext
}

func NewExprPowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPowContext {
	var p = new(ExprPowContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPowContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprPowContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprPowContext) POW() antlr.TerminalNode {
	return s.GetToken(ZggParserPOW, 0)
}

func (s *ExprPowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPow(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprWhenContext struct {
	*ExprContext
}

func NewExprWhenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprWhenContext {
	var p = new(ExprWhenContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ZggParserWHEN, 0)
}

func (s *ExprWhenContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *ExprWhenContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *ExprWhenContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprWhenContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWhenContext) AllLEAD_TO() []antlr.TerminalNode {
	return s.GetTokens(ZggParserLEAD_TO)
}

func (s *ExprWhenContext) LEAD_TO(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserLEAD_TO, i)
}

func (s *ExprWhenContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, 0)
}

func (s *ExprWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitShiftContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprBitShiftContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitShiftContext {
	var p = new(ExprBitShiftContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitShiftContext) GetOp() antlr.Token { return s.op }

func (s *ExprBitShiftContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprBitShiftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitShiftContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitShiftContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitShiftContext) BIT_SHL() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHL, 0)
}

func (s *ExprBitShiftContext) BIT_SHR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHR, 0)
}

func (s *ExprBitShiftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitShift(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicNotContext struct {
	*ExprContext
}

func NewExprLogicNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicNotContext {
	var p = new(ExprLogicNotContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicNotContext) LOGIC_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_NOT, 0)
}

func (s *ExprLogicNotContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprItByFieldContext struct {
	*ExprContext
	field antlr.Token
}

func NewExprItByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprItByFieldContext {
	var p = new(ExprItByFieldContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprItByFieldContext) GetField() antlr.Token { return s.field }

func (s *ExprItByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *ExprItByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprItByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *ExprItByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprItByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprItByField(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicAndContext struct {
	*ExprContext
}

func NewExprLogicAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicAndContext {
	var p = new(ExprLogicAndContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicAndContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprLogicAndContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicAndContext) LOGIC_AND() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_AND, 0)
}

func (s *ExprLogicAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprIdentifierContext struct {
	*ExprContext
}

func NewExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIdentifierContext {
	var p = new(ExprIdentifierContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprFallbackContext struct {
	*ExprContext
}

func NewExprFallbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprFallbackContext {
	var p = new(ExprFallbackContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprFallbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprFallbackContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprFallbackContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprFallbackContext) OPTIONAL_ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_ELSE, 0)
}

func (s *ExprFallbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprFallback(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitAndContext struct {
	*ExprContext
}

func NewExprBitAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitAndContext {
	var p = new(ExprBitAndContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitAndContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitAndContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitAndContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_AND, 0)
}

func (s *ExprBitAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprNegativeContext struct {
	*ExprContext
}

func NewExprNegativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprNegativeContext {
	var p = new(ExprNegativeContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprNegativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprNegativeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS, 0)
}

func (s *ExprNegativeContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprNegativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprNegative(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprTimesDivModContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprTimesDivModContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprTimesDivModContext {
	var p = new(ExprTimesDivModContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprTimesDivModContext) GetOp() antlr.Token { return s.op }

func (s *ExprTimesDivModContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprTimesDivModContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprTimesDivModContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprTimesDivModContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprTimesDivModContext) TIMES() antlr.TerminalNode {
	return s.GetToken(ZggParserTIMES, 0)
}

func (s *ExprTimesDivModContext) DIV() antlr.TerminalNode {
	return s.GetToken(ZggParserDIV, 0)
}

func (s *ExprTimesDivModContext) MOD() antlr.TerminalNode {
	return s.GetToken(ZggParserMOD, 0)
}

func (s *ExprTimesDivModContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprTimesDivMod(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprByIndexContext struct {
	*ExprContext
	index IExprContext
}

func NewExprByIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprByIndexContext {
	var p = new(ExprByIndexContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprByIndexContext) GetIndex() IExprContext { return s.index }

func (s *ExprByIndexContext) SetIndex(v IExprContext) { s.index = v }

func (s *ExprByIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprByIndexContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprByIndexContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprByIndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *ExprByIndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *ExprByIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprByIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitNotContext struct {
	*ExprContext
}

func NewExprBitNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitNotContext {
	var p = new(ExprBitNotContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitNotContext) BIT_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_NOT, 0)
}

func (s *ExprBitNotContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprShortImportContext struct {
	*ExprContext
}

func NewExprShortImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprShortImportContext {
	var p = new(ExprShortImportContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprShortImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprShortImportContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprShortImportContext) SINGLE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserSINGLE_AT, 0)
}

func (s *ExprShortImportContext) DOUBLE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOUBLE_AT, 0)
}

func (s *ExprShortImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprShortImport(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprSubContext struct {
	*ExprContext
}

func NewExprSubContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprSubContext {
	var p = new(ExprSubContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprSubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSubContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *ExprSubContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprSubContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *ExprSubContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprSub(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprCallContext struct {
	*ExprContext
}

func NewExprCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCallContext {
	var p = new(ExprCallContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCallContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCallContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ExprCallContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *ExprCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitOrContext struct {
	*ExprContext
}

func NewExprBitOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitOrContext {
	var p = new(ExprBitOrContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitOrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitOrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitOrContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_OR, 0)
}

func (s *ExprBitOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAssertErrorContext struct {
	*ExprContext
}

func NewExprAssertErrorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAssertErrorContext {
	var p = new(ExprAssertErrorContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAssertErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAssertErrorContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAssertErrorContext) LOGIC_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_NOT, 0)
}

func (s *ExprAssertErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprAssertError(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprQuestionContext struct {
	*ExprContext
	condition IExprContext
	trueExpr  IExprContext
	falseExpr IExprContext
}

func NewExprQuestionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprQuestionContext {
	var p = new(ExprQuestionContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprQuestionContext) GetCondition() IExprContext { return s.condition }

func (s *ExprQuestionContext) GetTrueExpr() IExprContext { return s.trueExpr }

func (s *ExprQuestionContext) GetFalseExpr() IExprContext { return s.falseExpr }

func (s *ExprQuestionContext) SetCondition(v IExprContext) { s.condition = v }

func (s *ExprQuestionContext) SetTrueExpr(v IExprContext) { s.trueExpr = v }

func (s *ExprQuestionContext) SetFalseExpr(v IExprContext) { s.falseExpr = v }

func (s *ExprQuestionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprQuestionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ZggParserQUESTION, 0)
}

func (s *ExprQuestionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *ExprQuestionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprQuestionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprQuestionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprQuestion(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPostIncDecContext struct {
	*ExprContext
}

func NewExprPostIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPostIncDecContext {
	var p = new(ExprPostIncDecContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPostIncDecContext) PostIncDec() IPostIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostIncDecContext)
}

func (s *ExprPostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBySliceContext struct {
	*ExprContext
	container IExprContext
	begin     IExprContext
	end       IExprContext
}

func NewExprBySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBySliceContext {
	var p = new(ExprBySliceContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBySliceContext) GetContainer() IExprContext { return s.container }

func (s *ExprBySliceContext) GetBegin() IExprContext { return s.begin }

func (s *ExprBySliceContext) GetEnd() IExprContext { return s.end }

func (s *ExprBySliceContext) SetContainer(v IExprContext) { s.container = v }

func (s *ExprBySliceContext) SetBegin(v IExprContext) { s.begin = v }

func (s *ExprBySliceContext) SetEnd(v IExprContext) { s.end = v }

func (s *ExprBySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBySliceContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *ExprBySliceContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *ExprBySliceContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *ExprBySliceContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBySliceContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBySliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBySlice(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprIsTypeContext struct {
	*ExprContext
}

func NewExprIsTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIsTypeContext {
	var p = new(ExprIsTypeContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIsTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIsTypeContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprIsTypeContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprIsTypeContext) IS() antlr.TerminalNode {
	return s.GetToken(ZggParserIS, 0)
}

func (s *ExprIsTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprIsType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *ZggParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 22
	p.EnterRecursionRule(localctx, 22, ZggParserRULE_expr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExprShortImportContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(332)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserSINGLE_AT || _la == ZggParserDOUBLE_AT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(333)
			p.Match(ZggParserIDENTIFIER)
		}

	case 2:
		localctx = NewExprPreIncDecContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(334)
			p.PreIncDec()
		}

	case 3:
		localctx = NewExprPostIncDecContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(335)
			p.PostIncDec()
		}

	case 4:
		localctx = NewExprItByFieldContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(336)
			p.Match(ZggParserDOT)
		}
		{
			p.SetState(337)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*ExprItByFieldContext).field = _m
		}

	case 5:
		localctx = NewExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(338)
			p.Match(ZggParserIDENTIFIER)
		}

	case 6:
		localctx = NewExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(339)
			p.Literal()
		}

	case 7:
		localctx = NewExprNegativeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(340)
			p.Match(ZggParserMINUS)
		}
		{
			p.SetState(341)
			p.expr(26)
		}

	case 8:
		localctx = NewExprLogicNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(342)
			p.Match(ZggParserLOGIC_NOT)
		}
		{
			p.SetState(343)
			p.expr(25)
		}

	case 9:
		localctx = NewExprBitNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(344)
			p.Match(ZggParserBIT_NOT)
		}
		{
			p.SetState(345)
			p.expr(24)
		}

	case 10:
		localctx = NewExprWhenContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(346)
			p.Match(ZggParserWHEN)
		}
		{
			p.SetState(347)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
			{
				p.SetState(348)
				p.expr(0)
			}
			{
				p.SetState(349)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(350)
				p.expr(0)
			}

			p.SetState(354)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(356)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(357)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(358)
				p.expr(0)
			}

		}
		{
			p.SetState(361)
			p.Match(ZggParserR_CURLY)
		}

	case 11:
		localctx = NewExprWhenValueContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(363)
			p.Match(ZggParserWHEN)
		}
		{
			p.SetState(364)
			p.expr(0)
		}
		{
			p.SetState(365)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ZggParserIS-34))|(1<<(ZggParserINT_ZERO-34))|(1<<(ZggParserINT_DEC-34))|(1<<(ZggParserINT_HEX-34))|(1<<(ZggParserINT_OCT-34))|(1<<(ZggParserINT_BIN-34))|(1<<(ZggParserBIGNUM-34))|(1<<(ZggParserFLOAT-34))|(1<<(ZggParserENUM-34))|(1<<(ZggParserSTRING-34))|(1<<(ZggParserRSTRING-34))|(1<<(ZggParserMORE_ARGS-34))|(1<<(ZggParserPLUS_PLUS-34))|(1<<(ZggParserMINUS_MINUS-34)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserRANGE_WITHOUT_END-71))|(1<<(ZggParserRANGE_WITH_END-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
			{
				p.SetState(366)
				p.WhenCondition()
			}
			{
				p.SetState(367)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(368)
				p.expr(0)
			}

			p.SetState(372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(374)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(375)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(376)
				p.expr(0)
			}

		}
		{
			p.SetState(379)
			p.Match(ZggParserR_CURLY)
		}

	case 12:
		localctx = NewExprAssignContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(381)
			p.AssignExpr()
		}

	case 13:
		localctx = NewExprSubContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(382)
			p.Match(ZggParserL_PAREN)
		}
		{
			p.SetState(383)
			p.expr(0)
		}
		{
			p.SetState(384)
			p.Match(ZggParserR_PAREN)
		}

	case 14:
		localctx = NewExprUseMethodContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(386)
			p.Match(ZggParserUSE_AT)
		}
		{
			p.SetState(387)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(388)
			p.expr(4)
		}

	case 15:
		localctx = NewExprUseBlockContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(389)
			p.Match(ZggParserUSE_AT)
		}
		{
			p.SetState(390)
			p.CodeBlock()
		}
		{
			p.SetState(391)
			p.expr(3)
		}

	case 16:
		localctx = NewExprUseCloserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(393)
			p.Match(ZggParserUSE)
		}
		{
			p.SetState(394)
			p.expr(2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(474)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprPowContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(397)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(398)
					p.Match(ZggParserPOW)
				}
				{
					p.SetState(399)
					p.expr(23)
				}

			case 2:
				localctx = NewExprTimesDivModContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(400)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(401)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprTimesDivModContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ZggParserTIMES-99))|(1<<(ZggParserDIV-99))|(1<<(ZggParserMOD-99)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprTimesDivModContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(402)
					p.expr(23)
				}

			case 3:
				localctx = NewExprPlusMinusContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(403)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(404)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprPlusMinusContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ZggParserPLUS || _la == ZggParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprPlusMinusContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(405)
					p.expr(22)
				}

			case 4:
				localctx = NewExprBitShiftContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(406)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(407)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprBitShiftContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ZggParserBIT_SHL || _la == ZggParserBIT_SHR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprBitShiftContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(408)
					p.expr(21)
				}

			case 5:
				localctx = NewExprBitAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(409)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(410)
					p.Match(ZggParserBIT_AND)
				}
				{
					p.SetState(411)
					p.expr(20)
				}

			case 6:
				localctx = NewExprBitOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(412)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(413)
					p.Match(ZggParserBIT_OR)
				}
				{
					p.SetState(414)
					p.expr(19)
				}

			case 7:
				localctx = NewExprBitXorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(415)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(416)
					p.Match(ZggParserBIT_XOR)
				}
				{
					p.SetState(417)
					p.expr(18)
				}

			case 8:
				localctx = NewExprCompareContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(418)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(419)
					p.Comparator()
				}
				{
					p.SetState(420)
					p.expr(17)
				}

			case 9:
				localctx = NewExprIsTypeContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(422)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(423)
					p.Match(ZggParserIS)
				}
				{
					p.SetState(424)
					p.expr(16)
				}

			case 10:
				localctx = NewExprInContainerContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(425)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(426)
					p.Match(ZggParserIN)
				}
				{
					p.SetState(427)
					p.expr(15)
				}

			case 11:
				localctx = NewExprInRangeContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(428)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(429)
					p.Match(ZggParserIN)
				}
				{
					p.SetState(430)
					p.expr(0)
				}
				{
					p.SetState(431)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(432)
					p.expr(14)
				}

			case 12:
				localctx = NewExprLogicAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(434)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(435)
					p.Match(ZggParserLOGIC_AND)
				}
				{
					p.SetState(436)
					p.expr(13)
				}

			case 13:
				localctx = NewExprLogicOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(437)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(438)
					p.Match(ZggParserLOGIC_OR)
				}
				{
					p.SetState(439)
					p.expr(12)
				}

			case 14:
				localctx = NewExprQuestionContext(p, NewExprContext(p, _parentctx, _parentState))
				localctx.(*ExprQuestionContext).condition = _prevctx

				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(440)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(441)
					p.Match(ZggParserQUESTION)
				}
				{
					p.SetState(442)

					var _x = p.expr(0)

					localctx.(*ExprQuestionContext).trueExpr = _x
				}
				{
					p.SetState(443)
					p.Match(ZggParserCOLON)
				}
				{
					p.SetState(444)

					var _x = p.expr(9)

					localctx.(*ExprQuestionContext).falseExpr = _x
				}

			case 15:
				localctx = NewExprFallbackContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(446)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(447)
					p.Match(ZggParserOPTIONAL_ELSE)
				}
				{
					p.SetState(448)
					p.expr(8)
				}

			case 16:
				localctx = NewExprCallContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(449)

				if !(p.Precpred(p.GetParserRuleContext(), 36)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 36)", ""))
				}
				p.SetState(451)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserOPTIONAL_CALL {
					{
						p.SetState(450)
						p.Match(ZggParserOPTIONAL_CALL)
					}

				}
				{
					p.SetState(453)
					p.Arguments()
				}

			case 17:
				localctx = NewExprByFieldContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(454)

				if !(p.Precpred(p.GetParserRuleContext(), 31)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 31)", ""))
				}
				{
					p.SetState(455)
					p.Match(ZggParserDOT)
				}
				{
					p.SetState(456)

					var _m = p.Match(ZggParserIDENTIFIER)

					localctx.(*ExprByFieldContext).field = _m
				}

			case 18:
				localctx = NewExprByIndexContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(457)

				if !(p.Precpred(p.GetParserRuleContext(), 30)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 30)", ""))
				}
				{
					p.SetState(458)
					p.Match(ZggParserL_BRACKET)
				}
				{
					p.SetState(459)

					var _x = p.expr(0)

					localctx.(*ExprByIndexContext).index = _x
				}
				{
					p.SetState(460)
					p.Match(ZggParserR_BRACKET)
				}

			case 19:
				localctx = NewExprBySliceContext(p, NewExprContext(p, _parentctx, _parentState))
				localctx.(*ExprBySliceContext).container = _prevctx

				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(462)

				if !(p.Precpred(p.GetParserRuleContext(), 29)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 29)", ""))
				}
				{
					p.SetState(463)
					p.Match(ZggParserL_BRACKET)
				}
				p.SetState(465)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
					{
						p.SetState(464)

						var _x = p.expr(0)

						localctx.(*ExprBySliceContext).begin = _x
					}

				}
				{
					p.SetState(467)
					p.Match(ZggParserCOLON)
				}
				p.SetState(469)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
					{
						p.SetState(468)

						var _x = p.expr(0)

						localctx.(*ExprBySliceContext).end = _x
					}

				}
				{
					p.SetState(471)
					p.Match(ZggParserR_BRACKET)
				}

			case 20:
				localctx = NewExprAssertErrorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(472)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(473)
					p.Match(ZggParserLOGIC_NOT)
				}

			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}

	return localctx
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_whenCondition
	return p
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) CopyFrom(ctx *WhenConditionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WhenConditionIsTypeContext struct {
	*WhenConditionContext
}

func NewWhenConditionIsTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenConditionIsTypeContext {
	var p = new(WhenConditionIsTypeContext)

	p.WhenConditionContext = NewEmptyWhenConditionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WhenConditionContext))

	return p
}

func (s *WhenConditionIsTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionIsTypeContext) IS() antlr.TerminalNode {
	return s.GetToken(ZggParserIS, 0)
}

func (s *WhenConditionIsTypeContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenConditionIsTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitWhenConditionIsType(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhenConditionInRangeContext struct {
	*WhenConditionContext
	lowerBound IExprContext
	upperBound IExprContext
}

func NewWhenConditionInRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenConditionInRangeContext {
	var p = new(WhenConditionInRangeContext)

	p.WhenConditionContext = NewEmptyWhenConditionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WhenConditionContext))

	return p
}

func (s *WhenConditionInRangeContext) GetLowerBound() IExprContext { return s.lowerBound }

func (s *WhenConditionInRangeContext) GetUpperBound() IExprContext { return s.upperBound }

func (s *WhenConditionInRangeContext) SetLowerBound(v IExprContext) { s.lowerBound = v }

func (s *WhenConditionInRangeContext) SetUpperBound(v IExprContext) { s.upperBound = v }

func (s *WhenConditionInRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionInRangeContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *WhenConditionInRangeContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *WhenConditionInRangeContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *WhenConditionInRangeContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenConditionInRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitWhenConditionInRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhenConditionInListContext struct {
	*WhenConditionContext
}

func NewWhenConditionInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenConditionInListContext {
	var p = new(WhenConditionInListContext)

	p.WhenConditionContext = NewEmptyWhenConditionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WhenConditionContext))

	return p
}

func (s *WhenConditionInListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionInListContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *WhenConditionInListContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenConditionInListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *WhenConditionInListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *WhenConditionInListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitWhenConditionInList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) WhenCondition() (localctx IWhenConditionContext) {
	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ZggParserRULE_whenCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWhenConditionInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.expr(0)
		}
		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserCOMMA {
			{
				p.SetState(480)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(481)
				p.expr(0)
			}

			p.SetState(486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewWhenConditionInRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
			{
				p.SetState(487)

				var _x = p.expr(0)

				localctx.(*WhenConditionInRangeContext).lowerBound = _x
			}

		}
		{
			p.SetState(490)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
			{
				p.SetState(491)

				var _x = p.expr(0)

				localctx.(*WhenConditionInRangeContext).upperBound = _x
			}

		}

	case 3:
		localctx = NewWhenConditionIsTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(494)
			p.Match(ZggParserIS)
		}
		{
			p.SetState(495)
			p.expr(0)
		}

	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *ArgumentsContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *ArgumentsContext) AllFuncArgument() []IFuncArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFuncArgumentContext)(nil)).Elem())
	var tst = make([]IFuncArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFuncArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentsContext) FuncArgument(i int) IFuncArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFuncArgumentContext)
}

func (s *ArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *ArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ZggParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(ZggParserL_PAREN)
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserMOD-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
		{
			p.SetState(499)
			p.FuncArgument()
		}
		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(500)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(501)
					p.FuncArgument()
				}

			}
			p.SetState(506)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(507)
				p.Match(ZggParserCOMMA)
			}

		}

	}
	{
		p.SetState(512)
		p.Match(ZggParserR_PAREN)
	}

	return localctx
}

// IFuncArgumentContext is an interface to support dynamic dispatch.
type IFuncArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPlaceholder returns the placeholder token.
	GetPlaceholder() antlr.Token

	// GetHoleIndex returns the holeIndex token.
	GetHoleIndex() antlr.Token

	// SetPlaceholder sets the placeholder token.
	SetPlaceholder(antlr.Token)

	// SetHoleIndex sets the holeIndex token.
	SetHoleIndex(antlr.Token)

	// GetSimpleArg returns the simpleArg rule contexts.
	GetSimpleArg() IExprContext

	// GetLambdaExpr returns the lambdaExpr rule contexts.
	GetLambdaExpr() IExprContext

	// SetSimpleArg sets the simpleArg rule contexts.
	SetSimpleArg(IExprContext)

	// SetLambdaExpr sets the lambdaExpr rule contexts.
	SetLambdaExpr(IExprContext)

	// IsFuncArgumentContext differentiates from other interfaces.
	IsFuncArgumentContext()
}

type FuncArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	simpleArg   IExprContext
	lambdaExpr  IExprContext
	placeholder antlr.Token
	holeIndex   antlr.Token
}

func NewEmptyFuncArgumentContext() *FuncArgumentContext {
	var p = new(FuncArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_funcArgument
	return p
}

func (*FuncArgumentContext) IsFuncArgumentContext() {}

func NewFuncArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncArgumentContext {
	var p = new(FuncArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_funcArgument

	return p
}

func (s *FuncArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncArgumentContext) GetPlaceholder() antlr.Token { return s.placeholder }

func (s *FuncArgumentContext) GetHoleIndex() antlr.Token { return s.holeIndex }

func (s *FuncArgumentContext) SetPlaceholder(v antlr.Token) { s.placeholder = v }

func (s *FuncArgumentContext) SetHoleIndex(v antlr.Token) { s.holeIndex = v }

func (s *FuncArgumentContext) GetSimpleArg() IExprContext { return s.simpleArg }

func (s *FuncArgumentContext) GetLambdaExpr() IExprContext { return s.lambdaExpr }

func (s *FuncArgumentContext) SetSimpleArg(v IExprContext) { s.simpleArg = v }

func (s *FuncArgumentContext) SetLambdaExpr(v IExprContext) { s.lambdaExpr = v }

func (s *FuncArgumentContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FuncArgumentContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *FuncArgumentContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *FuncArgumentContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FuncArgumentContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *FuncArgumentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *FuncArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *FuncArgumentContext) MOD() antlr.TerminalNode {
	return s.GetToken(ZggParserMOD, 0)
}

func (s *FuncArgumentContext) INT_ZERO() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_ZERO, 0)
}

func (s *FuncArgumentContext) INT_DEC() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_DEC, 0)
}

func (s *FuncArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitFuncArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) FuncArgument() (localctx IFuncArgumentContext) {
	localctx = NewFuncArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ZggParserRULE_funcArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
		case 1:
			p.SetState(515)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(514)
					p.Match(ZggParserMORE_ARGS)
				}

			}
			{
				p.SetState(517)

				var _x = p.expr(0)

				localctx.(*FuncArgumentContext).simpleArg = _x
			}

		case 2:
			{
				p.SetState(518)
				p.CodeBlock()
			}

		case 3:
			{
				p.SetState(519)
				p.Match(ZggParserL_CURLY)
			}
			{
				p.SetState(520)

				var _x = p.expr(0)

				localctx.(*FuncArgumentContext).lambdaExpr = _x
			}
			{
				p.SetState(521)
				p.Match(ZggParserR_CURLY)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(525)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(526)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(527)

			var _x = p.expr(0)

			localctx.(*FuncArgumentContext).simpleArg = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(528)

			var _m = p.Match(ZggParserMOD)

			localctx.(*FuncArgumentContext).placeholder = _m
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserINT_ZERO || _la == ZggParserINT_DEC {
			{
				p.SetState(529)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*FuncArgumentContext).holeIndex = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ZggParserINT_ZERO || _la == ZggParserINT_DEC) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*FuncArgumentContext).holeIndex = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}

	return localctx
}

// IAssignExprContext is an interface to support dynamic dispatch.
type IAssignExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignExprContext differentiates from other interfaces.
	IsAssignExprContext()
}

type AssignExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignExprContext() *AssignExprContext {
	var p = new(AssignExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_assignExpr
	return p
}

func (*AssignExprContext) IsAssignExprContext() {}

func NewAssignExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignExprContext {
	var p = new(AssignExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_assignExpr

	return p
}

func (s *AssignExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignExprContext) CopyFrom(ctx *AssignExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AssignExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssignNewLocalContext struct {
	*AssignExprContext
}

func NewAssignNewLocalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewLocalContext {
	var p = new(AssignNewLocalContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewLocalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewLocalContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *AssignNewLocalContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewLocalContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewLocalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewLocal(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignExistsContext struct {
	*AssignExprContext
	op antlr.Token
}

func NewAssignExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignExistsContext {
	var p = new(AssignExistsContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignExistsContext) GetOp() antlr.Token { return s.op }

func (s *AssignExistsContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExistsContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *AssignExistsContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignExistsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserASSIGN, 0)
}

func (s *AssignExistsContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_ASSIGN, 0)
}

func (s *AssignExistsContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_ASSIGN, 0)
}

func (s *AssignExistsContext) TIMES_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserTIMES_ASSIGN, 0)
}

func (s *AssignExistsContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserDIV_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_AND_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_OR_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_XOR_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_SHL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHL_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_SHR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHR_ASSIGN, 0)
}

func (s *AssignExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewDeObjectContext struct {
	*AssignExprContext
}

func NewAssignNewDeObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewDeObjectContext {
	var p = new(AssignNewDeObjectContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewDeObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewDeObjectContext) AllL_CURLY() []antlr.TerminalNode {
	return s.GetTokens(ZggParserL_CURLY)
}

func (s *AssignNewDeObjectContext) L_CURLY(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, i)
}

func (s *AssignNewDeObjectContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *AssignNewDeObjectContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *AssignNewDeObjectContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewDeObjectContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewDeObjectContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *AssignNewDeObjectContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *AssignNewDeObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewDeObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewContext struct {
	*AssignExprContext
}

func NewAssignNewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewContext {
	var p = new(AssignNewContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *AssignNewContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNew(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewDeArrayContext struct {
	*AssignExprContext
}

func NewAssignNewDeArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewDeArrayContext {
	var p = new(AssignNewDeArrayContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewDeArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewDeArrayContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *AssignNewDeArrayContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *AssignNewDeArrayContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *AssignNewDeArrayContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *AssignNewDeArrayContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewDeArrayContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewDeArrayContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *AssignNewDeArrayContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *AssignNewDeArrayContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *AssignNewDeArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewDeArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) AssignExpr() (localctx IAssignExprContext) {
	localctx = NewAssignExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ZggParserRULE_assignExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssignExistsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.lval(0)
		}
		{
			p.SetState(535)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignExistsContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(ZggParserPLUS_ASSIGN-60))|(1<<(ZggParserMINUS_ASSIGN-60))|(1<<(ZggParserTIMES_ASSIGN-60))|(1<<(ZggParserDIV_ASSIGN-60))|(1<<(ZggParserBIT_AND_ASSIGN-60))|(1<<(ZggParserBIT_OR_ASSIGN-60))|(1<<(ZggParserBIT_SHL_ASSIGN-60))|(1<<(ZggParserBIT_SHR_ASSIGN-60))|(1<<(ZggParserBIT_XOR_ASSIGN-60)))) != 0) || _la == ZggParserASSIGN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignExistsContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(536)
			p.expr(0)
		}

	case 2:
		localctx = NewAssignNewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(539)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(540)
			p.expr(0)
		}

	case 3:
		localctx = NewAssignNewDeArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(541)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(542)
			p.Match(ZggParserIDENTIFIER)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(543)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(544)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(550)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(551)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(552)
				p.Match(ZggParserIDENTIFIER)
			}

		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(555)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(558)
			p.Match(ZggParserR_BRACKET)
		}
		{
			p.SetState(559)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(560)
			p.expr(0)
		}

	case 4:
		localctx = NewAssignNewDeObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(561)
			p.Match(ZggParserL_CURLY)
		}
		{
			p.SetState(562)
			p.Match(ZggParserIDENTIFIER)
		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserCOMMA {
			{
				p.SetState(563)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(564)
				p.Match(ZggParserIDENTIFIER)
			}

			p.SetState(569)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(570)
			p.Match(ZggParserL_CURLY)
		}
		{
			p.SetState(571)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(572)
			p.expr(0)
		}

	case 5:
		localctx = NewAssignNewLocalContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(573)
			p.Match(ZggParserMORE_ARGS)
		}
		{
			p.SetState(574)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(575)
			p.expr(0)
		}

	}

	return localctx
}

// IPreIncDecContext is an interface to support dynamic dispatch.
type IPreIncDecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPreIncDecContext differentiates from other interfaces.
	IsPreIncDecContext()
}

type PreIncDecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPreIncDecContext() *PreIncDecContext {
	var p = new(PreIncDecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_preIncDec
	return p
}

func (*PreIncDecContext) IsPreIncDecContext() {}

func NewPreIncDecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreIncDecContext {
	var p = new(PreIncDecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_preIncDec

	return p
}

func (s *PreIncDecContext) GetParser() antlr.Parser { return s.parser }

func (s *PreIncDecContext) GetOp() antlr.Token { return s.op }

func (s *PreIncDecContext) SetOp(v antlr.Token) { s.op = v }

func (s *PreIncDecContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *PreIncDecContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_PLUS, 0)
}

func (s *PreIncDecContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_MINUS, 0)
}

func (s *PreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncDecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) PreIncDec() (localctx IPreIncDecContext) {
	localctx = NewPreIncDecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ZggParserRULE_preIncDec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PreIncDecContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ZggParserPLUS_PLUS || _la == ZggParserMINUS_MINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PreIncDecContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(579)
		p.lval(0)
	}

	return localctx
}

// IPostIncDecContext is an interface to support dynamic dispatch.
type IPostIncDecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPostIncDecContext differentiates from other interfaces.
	IsPostIncDecContext()
}

type PostIncDecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPostIncDecContext() *PostIncDecContext {
	var p = new(PostIncDecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_postIncDec
	return p
}

func (*PostIncDecContext) IsPostIncDecContext() {}

func NewPostIncDecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncDecContext {
	var p = new(PostIncDecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_postIncDec

	return p
}

func (s *PostIncDecContext) GetParser() antlr.Parser { return s.parser }

func (s *PostIncDecContext) GetOp() antlr.Token { return s.op }

func (s *PostIncDecContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostIncDecContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *PostIncDecContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_PLUS, 0)
}

func (s *PostIncDecContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_MINUS, 0)
}

func (s *PostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncDecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) PostIncDec() (localctx IPostIncDecContext) {
	localctx = NewPostIncDecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ZggParserRULE_postIncDec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.lval(0)
	}
	{
		p.SetState(582)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PostIncDecContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ZggParserPLUS_PLUS || _la == ZggParserMINUS_MINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PostIncDecContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILvalContext is an interface to support dynamic dispatch.
type ILvalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLvalContext differentiates from other interfaces.
	IsLvalContext()
}

type LvalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLvalContext() *LvalContext {
	var p = new(LvalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_lval
	return p
}

func (*LvalContext) IsLvalContext() {}

func NewLvalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LvalContext {
	var p = new(LvalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_lval

	return p
}

func (s *LvalContext) GetParser() antlr.Parser { return s.parser }

func (s *LvalContext) CopyFrom(ctx *LvalContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LvalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LvalByIdContext struct {
	*LvalContext
}

func NewLvalByIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByIdContext {
	var p = new(LvalByIdContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByIdContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *LvalByIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalById(s)

	default:
		return t.VisitChildren(s)
	}
}

type LvalByIndexContext struct {
	*LvalContext
	index IExprContext
}

func NewLvalByIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByIndexContext {
	var p = new(LvalByIndexContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByIndexContext) GetIndex() IExprContext { return s.index }

func (s *LvalByIndexContext) SetIndex(v IExprContext) { s.index = v }

func (s *LvalByIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByIndexContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *LvalByIndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *LvalByIndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *LvalByIndexContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LvalByIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalByIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type LvalItByFieldContext struct {
	*LvalContext
	field antlr.Token
}

func NewLvalItByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalItByFieldContext {
	var p = new(LvalItByFieldContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalItByFieldContext) GetField() antlr.Token { return s.field }

func (s *LvalItByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *LvalItByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalItByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *LvalItByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *LvalItByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalItByField(s)

	default:
		return t.VisitChildren(s)
	}
}

type LvalByFieldContext struct {
	*LvalContext
	field antlr.Token
}

func NewLvalByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByFieldContext {
	var p = new(LvalByFieldContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByFieldContext) GetField() antlr.Token { return s.field }

func (s *LvalByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *LvalByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByFieldContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *LvalByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *LvalByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *LvalByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalByField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Lval() (localctx ILvalContext) {
	return p.lval(0)
}

func (p *ZggParser) lval(_p int) (localctx ILvalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLvalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILvalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, ZggParserRULE_lval, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserDOT:
		localctx = NewLvalItByFieldContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(585)
			p.Match(ZggParserDOT)
		}
		{
			p.SetState(586)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*LvalItByFieldContext).field = _m
		}

	case ZggParserIDENTIFIER:
		localctx = NewLvalByIdContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(587)
			p.Match(ZggParserIDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(598)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLvalByFieldContext(p, NewLvalContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_lval)
				p.SetState(590)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(591)
					p.Match(ZggParserDOT)
				}
				{
					p.SetState(592)

					var _m = p.Match(ZggParserIDENTIFIER)

					localctx.(*LvalByFieldContext).field = _m
				}

			case 2:
				localctx = NewLvalByIndexContext(p, NewLvalContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_lval)
				p.SetState(593)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(594)
					p.Match(ZggParserL_BRACKET)
				}
				{
					p.SetState(595)

					var _x = p.expr(0)

					localctx.(*LvalByIndexContext).index = _x
				}
				{
					p.SetState(596)
					p.Match(ZggParserR_BRACKET)
				}

			}

		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}

	return localctx
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_integer
	return p
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) CopyFrom(ctx *IntegerContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IntegerHexContext struct {
	*IntegerContext
}

func NewIntegerHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerHexContext {
	var p = new(IntegerHexContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerHexContext) INT_HEX() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_HEX, 0)
}

func (s *IntegerHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerBinContext struct {
	*IntegerContext
}

func NewIntegerBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerBinContext {
	var p = new(IntegerBinContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerBinContext) INT_BIN() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_BIN, 0)
}

func (s *IntegerBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerBin(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerDecContext struct {
	*IntegerContext
}

func NewIntegerDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerDecContext {
	var p = new(IntegerDecContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerDecContext) INT_DEC() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_DEC, 0)
}

func (s *IntegerDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerZeroContext struct {
	*IntegerContext
}

func NewIntegerZeroContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerZeroContext {
	var p = new(IntegerZeroContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerZeroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerZeroContext) INT_ZERO() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_ZERO, 0)
}

func (s *IntegerZeroContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerZero(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerOctContext struct {
	*IntegerContext
}

func NewIntegerOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerOctContext {
	var p = new(IntegerOctContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerOctContext) INT_OCT() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_OCT, 0)
}

func (s *IntegerOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerOct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ZggParserRULE_integer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(608)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserINT_ZERO:
		localctx = NewIntegerZeroContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(603)
			p.Match(ZggParserINT_ZERO)
		}

	case ZggParserINT_DEC:
		localctx = NewIntegerDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(604)
			p.Match(ZggParserINT_DEC)
		}

	case ZggParserINT_HEX:
		localctx = NewIntegerHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(605)
			p.Match(ZggParserINT_HEX)
		}

	case ZggParserINT_OCT:
		localctx = NewIntegerOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(606)
			p.Match(ZggParserINT_OCT)
		}

	case ZggParserINT_BIN:
		localctx = NewIntegerBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(607)
			p.Match(ZggParserINT_BIN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LiteralFloatContext struct {
	*LiteralContext
}

func NewLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralFloatContext {
	var p = new(LiteralFloatContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ZggParserFLOAT, 0)
}

func (s *LiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralObjectContext struct {
	*LiteralContext
}

func NewLiteralObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralObjectContext {
	var p = new(LiteralObjectContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralObjectContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *LiteralObjectContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *LiteralObjectContext) AllObjItem() []IObjItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjItemContext)(nil)).Elem())
	var tst = make([]IObjItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjItemContext)
		}
	}

	return tst
}

func (s *LiteralObjectContext) ObjItem(i int) IObjItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjItemContext)
}

func (s *LiteralObjectContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralObjectContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralBoolContext struct {
	*LiteralContext
}

func NewLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralBoolContext {
	var p = new(LiteralBoolContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralBoolContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ZggParserTRUE, 0)
}

func (s *LiteralBoolContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ZggParserFALSE, 0)
}

func (s *LiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralArrayContext struct {
	*LiteralContext
}

func NewLiteralArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralArrayContext {
	var p = new(LiteralArrayContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralArrayContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *LiteralArrayContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *LiteralArrayContext) AllArrayItem() []IArrayItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayItemContext)(nil)).Elem())
	var tst = make([]IArrayItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayItemContext)
		}
	}

	return tst
}

func (s *LiteralArrayContext) ArrayItem(i int) IArrayItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *LiteralArrayContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralArrayContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralStringContext struct {
	*LiteralContext
}

func NewLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralStringContext {
	var p = new(LiteralStringContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralStringContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralLambdaExprContext struct {
	*LiteralContext
}

func NewLiteralLambdaExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralLambdaExprContext {
	var p = new(LiteralLambdaExprContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralLambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralLambdaExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ZggParserARROW, 0)
}

func (s *LiteralLambdaExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LiteralLambdaExprContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralLambdaExprContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralLambdaExprContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralLambdaExprContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralLambdaExprContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralLambdaExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralLambdaExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralLambdaExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralLambdaExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralENumContext struct {
	*LiteralContext
}

func NewLiteralENumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralENumContext {
	var p = new(LiteralENumContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralENumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralENumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ZggParserENUM, 0)
}

func (s *LiteralENumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralENum(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralNilContext struct {
	*LiteralContext
}

func NewLiteralNilContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralNilContext {
	var p = new(LiteralNilContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralNilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralNilContext) NIL() antlr.TerminalNode {
	return s.GetToken(ZggParserNIL, 0)
}

func (s *LiteralNilContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralNil(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralUndefinedContext struct {
	*LiteralContext
}

func NewLiteralUndefinedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralUndefinedContext {
	var p = new(LiteralUndefinedContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralUndefinedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralUndefinedContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ZggParserUNDEFINED, 0)
}

func (s *LiteralUndefinedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralUndefined(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralFuncContext struct {
	*LiteralContext
}

func NewLiteralFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralFuncContext {
	var p = new(LiteralFuncContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralFuncContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *LiteralFuncContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralFuncContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralFuncContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LiteralFuncContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralFuncContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralFuncContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralFuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralFuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralLambdaBlockContext struct {
	*LiteralContext
}

func NewLiteralLambdaBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralLambdaBlockContext {
	var p = new(LiteralLambdaBlockContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralLambdaBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralLambdaBlockContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ZggParserARROW, 0)
}

func (s *LiteralLambdaBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LiteralLambdaBlockContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralLambdaBlockContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralLambdaBlockContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralLambdaBlockContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralLambdaBlockContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralLambdaBlockContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralLambdaBlockContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralLambdaBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralLambdaBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayComprehensionContext struct {
	*LiteralContext
	itemExpr IExprContext
	indexer  antlr.Token
	value    antlr.Token
	begin    IExprContext
	end      IExprContext
	filter   IExprContext
}

func NewArrayComprehensionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayComprehensionContext {
	var p = new(ArrayComprehensionContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *ArrayComprehensionContext) GetIndexer() antlr.Token { return s.indexer }

func (s *ArrayComprehensionContext) GetValue() antlr.Token { return s.value }

func (s *ArrayComprehensionContext) SetIndexer(v antlr.Token) { s.indexer = v }

func (s *ArrayComprehensionContext) SetValue(v antlr.Token) { s.value = v }

func (s *ArrayComprehensionContext) GetItemExpr() IExprContext { return s.itemExpr }

func (s *ArrayComprehensionContext) GetBegin() IExprContext { return s.begin }

func (s *ArrayComprehensionContext) GetEnd() IExprContext { return s.end }

func (s *ArrayComprehensionContext) GetFilter() IExprContext { return s.filter }

func (s *ArrayComprehensionContext) SetItemExpr(v IExprContext) { s.itemExpr = v }

func (s *ArrayComprehensionContext) SetBegin(v IExprContext) { s.begin = v }

func (s *ArrayComprehensionContext) SetEnd(v IExprContext) { s.end = v }

func (s *ArrayComprehensionContext) SetFilter(v IExprContext) { s.filter = v }

func (s *ArrayComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayComprehensionContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *ArrayComprehensionContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *ArrayComprehensionContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *ArrayComprehensionContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *ArrayComprehensionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ArrayComprehensionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayComprehensionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *ArrayComprehensionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *ArrayComprehensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *ArrayComprehensionContext) IF() antlr.TerminalNode {
	return s.GetToken(ZggParserIF, 0)
}

func (s *ArrayComprehensionContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *ArrayComprehensionContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *ArrayComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitArrayComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralIntegerContext struct {
	*LiteralContext
}

func NewLiteralIntegerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralIntegerContext {
	var p = new(LiteralIntegerContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralIntegerContext) Integer() IIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *LiteralIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralBigNumContext struct {
	*LiteralContext
}

func NewLiteralBigNumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralBigNumContext {
	var p = new(LiteralBigNumContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralBigNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralBigNumContext) BIGNUM() antlr.TerminalNode {
	return s.GetToken(ZggParserBIGNUM, 0)
}

func (s *LiteralBigNumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralBigNum(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectComprehensionContext struct {
	*LiteralContext
	keyExpr   IExprContext
	valueExpr IExprContext
	indexer   antlr.Token
	value     antlr.Token
	begin     IExprContext
	end       IExprContext
	filter    IExprContext
}

func NewObjectComprehensionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectComprehensionContext {
	var p = new(ObjectComprehensionContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *ObjectComprehensionContext) GetIndexer() antlr.Token { return s.indexer }

func (s *ObjectComprehensionContext) GetValue() antlr.Token { return s.value }

func (s *ObjectComprehensionContext) SetIndexer(v antlr.Token) { s.indexer = v }

func (s *ObjectComprehensionContext) SetValue(v antlr.Token) { s.value = v }

func (s *ObjectComprehensionContext) GetKeyExpr() IExprContext { return s.keyExpr }

func (s *ObjectComprehensionContext) GetValueExpr() IExprContext { return s.valueExpr }

func (s *ObjectComprehensionContext) GetBegin() IExprContext { return s.begin }

func (s *ObjectComprehensionContext) GetEnd() IExprContext { return s.end }

func (s *ObjectComprehensionContext) GetFilter() IExprContext { return s.filter }

func (s *ObjectComprehensionContext) SetKeyExpr(v IExprContext) { s.keyExpr = v }

func (s *ObjectComprehensionContext) SetValueExpr(v IExprContext) { s.valueExpr = v }

func (s *ObjectComprehensionContext) SetBegin(v IExprContext) { s.begin = v }

func (s *ObjectComprehensionContext) SetEnd(v IExprContext) { s.end = v }

func (s *ObjectComprehensionContext) SetFilter(v IExprContext) { s.filter = v }

func (s *ObjectComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComprehensionContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *ObjectComprehensionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *ObjectComprehensionContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *ObjectComprehensionContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *ObjectComprehensionContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *ObjectComprehensionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ObjectComprehensionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectComprehensionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *ObjectComprehensionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *ObjectComprehensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *ObjectComprehensionContext) IF() antlr.TerminalNode {
	return s.GetToken(ZggParserIF, 0)
}

func (s *ObjectComprehensionContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *ObjectComprehensionContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *ObjectComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitObjectComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ZggParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralIntegerContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Integer()
		}

	case 2:
		localctx = NewLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Match(ZggParserFLOAT)
		}

	case 3:
		localctx = NewLiteralENumContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(612)
			p.Match(ZggParserENUM)
		}

	case 4:
		localctx = NewLiteralBigNumContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(613)
			p.Match(ZggParserBIGNUM)
		}

	case 5:
		localctx = NewLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(614)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserTRUE || _la == ZggParserFALSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		localctx = NewLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(615)
			p.StringLiteral()
		}

	case 7:
		localctx = NewLiteralNilContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(616)
			p.Match(ZggParserNIL)
		}

	case 8:
		localctx = NewLiteralUndefinedContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(617)
			p.Match(ZggParserUNDEFINED)
		}

	case 9:
		localctx = NewLiteralFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(618)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(619)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(620)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(625)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(621)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(622)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(627)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
			}
			p.SetState(631)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(628)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(629)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(630)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(633)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(636)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(637)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(640)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(641)
			p.CodeBlock()
		}

	case 10:
		localctx = NewLiteralLambdaExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(665)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserL_PAREN:
			{
				p.SetState(642)
				p.Match(ZggParserL_PAREN)
			}
			p.SetState(661)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ZggParserIDENTIFIER:
				{
					p.SetState(643)
					p.Match(ZggParserIDENTIFIER)
				}
				p.SetState(648)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(644)
							p.Match(ZggParserCOMMA)
						}
						{
							p.SetState(645)
							p.Match(ZggParserIDENTIFIER)
						}

					}
					p.SetState(650)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
				}
				p.SetState(654)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(651)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(652)
						p.Match(ZggParserMORE_ARGS)
					}
					{
						p.SetState(653)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(657)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserCOMMA {
					{
						p.SetState(656)
						p.Match(ZggParserCOMMA)
					}

				}

			case ZggParserMORE_ARGS:
				{
					p.SetState(659)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(660)
					p.Match(ZggParserIDENTIFIER)
				}

			case ZggParserR_PAREN:

			default:
			}
			{
				p.SetState(663)
				p.Match(ZggParserR_PAREN)
			}

		case ZggParserIDENTIFIER:
			{
				p.SetState(664)
				p.Match(ZggParserIDENTIFIER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(667)
			p.Match(ZggParserARROW)
		}
		{
			p.SetState(668)
			p.expr(0)
		}

	case 11:
		localctx = NewLiteralLambdaBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		p.SetState(692)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserL_PAREN:
			{
				p.SetState(669)
				p.Match(ZggParserL_PAREN)
			}
			p.SetState(688)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ZggParserIDENTIFIER:
				{
					p.SetState(670)
					p.Match(ZggParserIDENTIFIER)
				}
				p.SetState(675)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(671)
							p.Match(ZggParserCOMMA)
						}
						{
							p.SetState(672)
							p.Match(ZggParserIDENTIFIER)
						}

					}
					p.SetState(677)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
				}
				p.SetState(681)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(678)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(679)
						p.Match(ZggParserMORE_ARGS)
					}
					{
						p.SetState(680)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(684)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserCOMMA {
					{
						p.SetState(683)
						p.Match(ZggParserCOMMA)
					}

				}

			case ZggParserMORE_ARGS:
				{
					p.SetState(686)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(687)
					p.Match(ZggParserIDENTIFIER)
				}

			case ZggParserR_PAREN:

			default:
			}
			{
				p.SetState(690)
				p.Match(ZggParserR_PAREN)
			}

		case ZggParserIDENTIFIER:
			{
				p.SetState(691)
				p.Match(ZggParserIDENTIFIER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(694)
			p.Match(ZggParserARROW)
		}
		{
			p.SetState(695)
			p.CodeBlock()
		}

	case 12:
		localctx = NewLiteralObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(696)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(ZggParserSTRING-47))|(1<<(ZggParserRSTRING-47))|(1<<(ZggParserMORE_ARGS-47)))) != 0) || (((_la-90)&-(0x1f+1)) == 0 && ((1<<uint((_la-90)))&((1<<(ZggParserL_BRACKET-90))|(1<<(ZggParserQUOTE-90))|(1<<(ZggParserIDENTIFIER-90)))) != 0) {
			{
				p.SetState(697)
				p.ObjItem()
			}
			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(698)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(699)
						p.ObjItem()
					}

				}
				p.SetState(704)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
			}
			p.SetState(706)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(705)
					p.Match(ZggParserCOMMA)
				}

			}

		}
		{
			p.SetState(710)
			p.Match(ZggParserR_CURLY)
		}

	case 13:
		localctx = NewObjectComprehensionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(711)
			p.Match(ZggParserL_CURLY)
		}
		{
			p.SetState(712)

			var _x = p.expr(0)

			localctx.(*ObjectComprehensionContext).keyExpr = _x
		}
		{
			p.SetState(713)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(714)

			var _x = p.expr(0)

			localctx.(*ObjectComprehensionContext).valueExpr = _x
		}
		{
			p.SetState(715)
			p.Match(ZggParserFOR)
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(716)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*ObjectComprehensionContext).indexer = _m
			}
			{
				p.SetState(717)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(720)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*ObjectComprehensionContext).value = _m
		}
		{
			p.SetState(721)
			p.Match(ZggParserIN)
		}
		{
			p.SetState(722)

			var _x = p.expr(0)

			localctx.(*ObjectComprehensionContext).begin = _x
		}
		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END {
			{
				p.SetState(723)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(724)

				var _x = p.expr(0)

				localctx.(*ObjectComprehensionContext).end = _x
			}

		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIF {
			{
				p.SetState(727)
				p.Match(ZggParserIF)
			}
			{
				p.SetState(728)

				var _x = p.expr(0)

				localctx.(*ObjectComprehensionContext).filter = _x
			}

		}
		{
			p.SetState(731)
			p.Match(ZggParserR_CURLY)
		}

	case 14:
		localctx = NewLiteralArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(733)
			p.Match(ZggParserL_BRACKET)
		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(ZggParserINT_ZERO-39))|(1<<(ZggParserINT_DEC-39))|(1<<(ZggParserINT_HEX-39))|(1<<(ZggParserINT_OCT-39))|(1<<(ZggParserINT_BIN-39))|(1<<(ZggParserBIGNUM-39))|(1<<(ZggParserFLOAT-39))|(1<<(ZggParserENUM-39))|(1<<(ZggParserSTRING-39))|(1<<(ZggParserRSTRING-39))|(1<<(ZggParserMORE_ARGS-39))|(1<<(ZggParserPLUS_PLUS-39))|(1<<(ZggParserMINUS_MINUS-39)))) != 0) || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(ZggParserBIT_NOT-71))|(1<<(ZggParserDOT-71))|(1<<(ZggParserL_PAREN-71))|(1<<(ZggParserL_CURLY-71))|(1<<(ZggParserL_BRACKET-71))|(1<<(ZggParserLOGIC_NOT-71))|(1<<(ZggParserMINUS-71))|(1<<(ZggParserSINGLE_AT-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserDOUBLE_AT-103))|(1<<(ZggParserQUOTE-103))|(1<<(ZggParserIDENTIFIER-103)))) != 0) {
			{
				p.SetState(734)
				p.ArrayItem()
			}
			p.SetState(739)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(735)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(736)
						p.ArrayItem()
					}

				}
				p.SetState(741)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
			}
			p.SetState(743)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(742)
					p.Match(ZggParserCOMMA)
				}

			}

		}
		{
			p.SetState(747)
			p.Match(ZggParserR_BRACKET)
		}

	case 15:
		localctx = NewArrayComprehensionContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(748)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(749)

			var _x = p.expr(0)

			localctx.(*ArrayComprehensionContext).itemExpr = _x
		}
		{
			p.SetState(750)
			p.Match(ZggParserFOR)
		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(751)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*ArrayComprehensionContext).indexer = _m
			}
			{
				p.SetState(752)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(755)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*ArrayComprehensionContext).value = _m
		}
		{
			p.SetState(756)
			p.Match(ZggParserIN)
		}
		{
			p.SetState(757)

			var _x = p.expr(0)

			localctx.(*ArrayComprehensionContext).begin = _x
		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END {
			{
				p.SetState(758)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(759)

				var _x = p.expr(0)

				localctx.(*ArrayComprehensionContext).end = _x
			}

		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIF {
			{
				p.SetState(762)
				p.Match(ZggParserIF)
			}
			{
				p.SetState(763)

				var _x = p.expr(0)

				localctx.(*ArrayComprehensionContext).filter = _x
			}

		}
		{
			p.SetState(766)
			p.Match(ZggParserR_BRACKET)
		}

	}

	return localctx
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// IsArrayItemContext differentiates from other interfaces.
	IsArrayItemContext()
}

type ArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
}

func NewEmptyArrayItemContext() *ArrayItemContext {
	var p = new(ArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_arrayItem
	return p
}

func (*ArrayItemContext) IsArrayItemContext() {}

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext {
	var p = new(ArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_arrayItem

	return p
}

func (s *ArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemContext) GetCondition() IExprContext { return s.condition }

func (s *ArrayItemContext) SetCondition(v IExprContext) { s.condition = v }

func (s *ArrayItemContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ArrayItemContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayItemContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *ArrayItemContext) IF() antlr.TerminalNode {
	return s.GetToken(ZggParserIF, 0)
}

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitArrayItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ArrayItem() (localctx IArrayItemContext) {
	localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ZggParserRULE_arrayItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(770)
			p.Match(ZggParserMORE_ARGS)
		}

	}
	{
		p.SetState(773)
		p.expr(0)
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserIF {
		{
			p.SetState(774)
			p.Match(ZggParserIF)
		}
		{
			p.SetState(775)

			var _x = p.expr(0)

			localctx.(*ArrayItemContext).condition = _x
		}

	}

	return localctx
}

// IObjItemContext is an interface to support dynamic dispatch.
type IObjItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjItemContext differentiates from other interfaces.
	IsObjItemContext()
}

type ObjItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjItemContext() *ObjItemContext {
	var p = new(ObjItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_objItem
	return p
}

func (*ObjItemContext) IsObjItemContext() {}

func NewObjItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjItemContext {
	var p = new(ObjItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_objItem

	return p
}

func (s *ObjItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjItemContext) CopyFrom(ctx *ObjItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ObjItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ObjItemExpandedContext struct {
	*ObjItemContext
}

func NewObjItemExpandedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjItemExpandedContext {
	var p = new(ObjItemExpandedContext)

	p.ObjItemContext = NewEmptyObjItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ObjItemContext))

	return p
}

func (s *ObjItemExpandedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemExpandedContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *ObjItemExpandedContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjItemExpandedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitObjItemExpanded(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjItemKVContext struct {
	*ObjItemContext
}

func NewObjItemKVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjItemKVContext {
	var p = new(ObjItemKVContext)

	p.ObjItemContext = NewEmptyObjItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ObjItemContext))

	return p
}

func (s *ObjItemKVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemKVContext) KeyValue() IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *ObjItemKVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitObjItemKV(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ObjItem() (localctx IObjItemContext) {
	localctx = NewObjItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ZggParserRULE_objItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(781)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserSTRING, ZggParserRSTRING, ZggParserL_BRACKET, ZggParserQUOTE, ZggParserIDENTIFIER:
		localctx = NewObjItemKVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(778)
			p.KeyValue()
		}

	case ZggParserMORE_ARGS:
		localctx = NewObjItemExpandedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(779)
			p.Match(ZggParserMORE_ARGS)
		}
		{
			p.SetState(780)
			p.expr(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyValueContext is an interface to support dynamic dispatch.
type IKeyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyValueContext differentiates from other interfaces.
	IsKeyValueContext()
}

type KeyValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyValueContext() *KeyValueContext {
	var p = new(KeyValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_keyValue
	return p
}

func (*KeyValueContext) IsKeyValueContext() {}

func NewKeyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyValueContext {
	var p = new(KeyValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_keyValue

	return p
}

func (s *KeyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyValueContext) CopyFrom(ctx *KeyValueContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *KeyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KVStrKeyContext struct {
	*KeyValueContext
}

func NewKVStrKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVStrKeyContext {
	var p = new(KVStrKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVStrKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVStrKeyContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *KVStrKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVStrKeyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVStrKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVStrKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVKeyFuncContext struct {
	*KeyValueContext
}

func NewKVKeyFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVKeyFuncContext {
	var p = new(KVKeyFuncContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVKeyFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVKeyFuncContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *KVKeyFuncContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *KVKeyFuncContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *KVKeyFuncContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *KVKeyFuncContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *KVKeyFuncContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *KVKeyFuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *KVKeyFuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *KVKeyFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVKeyFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVExprOnlyContext struct {
	*KeyValueContext
}

func NewKVExprOnlyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVExprOnlyContext {
	var p = new(KVExprOnlyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVExprOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVExprOnlyContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *KVExprOnlyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVExprOnlyContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *KVExprOnlyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVExprOnly(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVIdOnlyContext struct {
	*KeyValueContext
}

func NewKVIdOnlyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVIdOnlyContext {
	var p = new(KVIdOnlyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVIdOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVIdOnlyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *KVIdOnlyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVIdOnly(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVExprKeyContext struct {
	*KeyValueContext
}

func NewKVExprKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVExprKeyContext {
	var p = new(KVExprKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVExprKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVExprKeyContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *KVExprKeyContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *KVExprKeyContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVExprKeyContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *KVExprKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVExprKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVExprKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVIdKeyContext struct {
	*KeyValueContext
}

func NewKVIdKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVIdKeyContext {
	var p = new(KVIdKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVIdKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVIdKeyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *KVIdKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVIdKeyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVIdKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVIdKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) KeyValue() (localctx IKeyValueContext) {
	localctx = NewKeyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ZggParserRULE_keyValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKVIdKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(783)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(784)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(785)
			p.expr(0)
		}

	case 2:
		localctx = NewKVStrKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(786)
			p.StringLiteral()
		}
		{
			p.SetState(787)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(788)
			p.expr(0)
		}

	case 3:
		localctx = NewKVExprKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(790)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(791)
			p.expr(0)
		}
		{
			p.SetState(792)
			p.Match(ZggParserR_BRACKET)
		}
		{
			p.SetState(793)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(794)
			p.expr(0)
		}

	case 4:
		localctx = NewKVKeyFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(796)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(797)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(798)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(803)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(799)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(800)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(805)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(806)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(807)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(808)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(812)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(811)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(814)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(815)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(818)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(819)
			p.CodeBlock()
		}

	case 5:
		localctx = NewKVIdOnlyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(820)
			p.Match(ZggParserIDENTIFIER)
		}

	case 6:
		localctx = NewKVExprOnlyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(821)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(822)
			p.expr(0)
		}
		{
			p.SetState(823)
			p.Match(ZggParserR_BRACKET)
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(ZggParserSTRING, 0)
}

func (s *StringLiteralContext) RSTRING() antlr.TerminalNode {
	return s.GetToken(ZggParserRSTRING, 0)
}

func (s *StringLiteralContext) TemplateString() ITemplateStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ZggParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(830)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(827)
			p.Match(ZggParserSTRING)
		}

	case ZggParserRSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(828)
			p.Match(ZggParserRSTRING)
		}

	case ZggParserQUOTE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(829)
			p.TemplateString()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITemplateStringContext is an interface to support dynamic dispatch.
type ITemplateStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateStringContext differentiates from other interfaces.
	IsTemplateStringContext()
}

type TemplateStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringContext() *TemplateStringContext {
	var p = new(TemplateStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_templateString
	return p
}

func (*TemplateStringContext) IsTemplateStringContext() {}

func NewTemplateStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringContext {
	var p = new(TemplateStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_templateString

	return p
}

func (s *TemplateStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringContext) AllQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ZggParserQUOTE)
}

func (s *TemplateStringContext) QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserQUOTE, i)
}

func (s *TemplateStringContext) AllTsItem() []ITsItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITsItemContext)(nil)).Elem())
	var tst = make([]ITsItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITsItemContext)
		}
	}

	return tst
}

func (s *TemplateStringContext) TsItem(i int) ITsItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITsItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITsItemContext)
}

func (s *TemplateStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTemplateString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) TemplateString() (localctx ITemplateStringContext) {
	localctx = NewTemplateStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ZggParserRULE_templateString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Match(ZggParserQUOTE)
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(ZggParserTS_RAW-106))|(1<<(ZggParserTS_EXPR_START-106))|(1<<(ZggParserTS_IDENTIFIER-106)))) != 0 {
		{
			p.SetState(833)
			p.TsItem()
		}

		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(839)
		p.Match(ZggParserQUOTE)
	}

	return localctx
}

// ITsItemContext is an interface to support dynamic dispatch.
type ITsItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTsItemContext differentiates from other interfaces.
	IsTsItemContext()
}

type TsItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsItemContext() *TsItemContext {
	var p = new(TsItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_tsItem
	return p
}

func (*TsItemContext) IsTsItemContext() {}

func NewTsItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsItemContext {
	var p = new(TsItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_tsItem

	return p
}

func (s *TsItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TsItemContext) CopyFrom(ctx *TsItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TsItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TsRawContext struct {
	*TsItemContext
}

func NewTsRawContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsRawContext {
	var p = new(TsRawContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsRawContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsRawContext) TS_RAW() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_RAW, 0)
}

func (s *TsRawContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsRaw(s)

	default:
		return t.VisitChildren(s)
	}
}

type TsExprContext struct {
	*TsItemContext
}

func NewTsExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsExprContext {
	var p = new(TsExprContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsExprContext) TS_EXPR_START() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_EXPR_START, 0)
}

func (s *TsExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TsExprContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *TsExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type TsIdentifierContext struct {
	*TsItemContext
}

func NewTsIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsIdentifierContext {
	var p = new(TsIdentifierContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsIdentifierContext) TS_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_IDENTIFIER, 0)
}

func (s *TsIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) TsItem() (localctx ITsItemContext) {
	localctx = NewTsItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ZggParserRULE_tsItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserTS_RAW:
		localctx = NewTsRawContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Match(ZggParserTS_RAW)
		}

	case ZggParserTS_IDENTIFIER:
		localctx = NewTsIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.Match(ZggParserTS_IDENTIFIER)
		}

	case ZggParserTS_EXPR_START:
		localctx = NewTsExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(843)
			p.Match(ZggParserTS_EXPR_START)
		}
		{
			p.SetState(844)
			p.expr(0)
		}
		{
			p.SetState(845)
			p.Match(ZggParserR_CURLY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *ZggParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 11:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 18:
		var t *LvalContext = nil
		if localctx != nil {
			t = localctx.(*LvalContext)
		}
		return p.Lval_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ZggParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 36)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 31)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 30)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 29)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ZggParser) Lval_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 20:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
