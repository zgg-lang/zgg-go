// Code generated from parser/ZggParser.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // ZggParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 108, 766,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 3,
	2, 3, 2, 5, 2, 59, 10, 2, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 65, 10, 4, 7, 4,
	67, 10, 4, 12, 4, 14, 4, 70, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 87, 10, 6,
	12, 6, 14, 6, 90, 11, 6, 3, 6, 3, 6, 3, 6, 5, 6, 95, 10, 6, 3, 6, 5, 6,
	98, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 103, 10, 6, 5, 6, 105, 10, 6, 3, 6,
	3, 6, 3, 6, 5, 6, 110, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	118, 10, 6, 3, 6, 3, 6, 5, 6, 122, 10, 6, 3, 6, 3, 6, 7, 6, 126, 10, 6,
	12, 6, 14, 6, 129, 11, 6, 3, 6, 3, 6, 3, 6, 5, 6, 134, 10, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 146, 10, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 151, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 158,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 164, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 173, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	5, 6, 181, 10, 6, 3, 6, 3, 6, 5, 6, 185, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 195, 10, 6, 12, 6, 14, 6, 198, 11, 6, 3,
	6, 3, 6, 5, 6, 202, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 6, 6, 208, 10, 6, 13,
	6, 14, 6, 209, 3, 6, 5, 6, 213, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5,
	6, 220, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 7, 6, 235, 10, 6, 12, 6, 14, 6, 238, 11, 6, 3, 6,
	3, 6, 3, 6, 5, 6, 243, 10, 6, 3, 6, 5, 6, 246, 10, 6, 3, 6, 3, 6, 5, 6,
	250, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 257, 10, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 270, 10, 6,
	3, 6, 3, 6, 5, 6, 274, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 280, 10, 6,
	3, 6, 5, 6, 283, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 289, 10, 6, 12, 6,
	14, 6, 292, 11, 6, 3, 6, 3, 6, 5, 6, 296, 10, 6, 3, 7, 3, 7, 3, 7, 5, 7,
	301, 10, 7, 3, 7, 3, 7, 3, 8, 5, 8, 306, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9,
	5, 9, 312, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 317, 10, 9, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 5, 10, 324, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12,
	3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 6, 13,
	351, 10, 13, 13, 13, 14, 13, 352, 3, 13, 3, 13, 3, 13, 5, 13, 358, 10,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 6, 13,
	369, 10, 13, 13, 13, 14, 13, 370, 3, 13, 3, 13, 3, 13, 5, 13, 376, 10,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 394, 10, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 438,
	10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 7, 13, 451, 10, 13, 12, 13, 14, 13, 454, 11, 13, 3, 14, 3,
	14, 3, 14, 7, 14, 459, 10, 14, 12, 14, 14, 14, 462, 11, 14, 3, 14, 5, 14,
	465, 10, 14, 3, 14, 3, 14, 5, 14, 469, 10, 14, 5, 14, 471, 10, 14, 3, 15,
	3, 15, 3, 15, 3, 15, 7, 15, 477, 10, 15, 12, 15, 14, 15, 480, 11, 15, 3,
	15, 5, 15, 483, 10, 15, 5, 15, 485, 10, 15, 3, 15, 3, 15, 3, 16, 5, 16,
	490, 10, 16, 3, 16, 3, 16, 5, 16, 494, 10, 16, 3, 16, 3, 16, 3, 16, 5,
	16, 499, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 7, 17, 512, 10, 17, 12, 17, 14, 17, 515, 11, 17, 3,
	17, 3, 17, 3, 17, 5, 17, 520, 10, 17, 3, 17, 5, 17, 523, 10, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 532, 10, 17, 12, 17, 14,
	17, 535, 11, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 543,
	10, 17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 562, 10,
	20, 12, 20, 14, 20, 565, 11, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5,
	21, 572, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 586, 10, 22, 12, 22, 14, 22, 589, 11,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 594, 10, 22, 3, 22, 5, 22, 597, 10, 22,
	3, 22, 3, 22, 5, 22, 601, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 7, 22, 609, 10, 22, 12, 22, 14, 22, 612, 11, 22, 3, 22, 3, 22, 3, 22,
	5, 22, 617, 10, 22, 3, 22, 5, 22, 620, 10, 22, 3, 22, 3, 22, 5, 22, 624,
	10, 22, 3, 22, 3, 22, 5, 22, 628, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 7, 22, 636, 10, 22, 12, 22, 14, 22, 639, 11, 22, 3, 22, 3, 22,
	3, 22, 5, 22, 644, 10, 22, 3, 22, 5, 22, 647, 10, 22, 3, 22, 3, 22, 5,
	22, 651, 10, 22, 3, 22, 3, 22, 5, 22, 655, 10, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 7, 22, 663, 10, 22, 12, 22, 14, 22, 666, 11, 22, 3,
	22, 5, 22, 669, 10, 22, 5, 22, 671, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 7, 22, 678, 10, 22, 12, 22, 14, 22, 681, 11, 22, 3, 22, 5, 22, 684,
	10, 22, 5, 22, 686, 10, 22, 3, 22, 5, 22, 689, 10, 22, 3, 23, 5, 23, 692,
	10, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 5, 24, 699, 10, 24, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 719, 10, 25, 12, 25, 14,
	25, 722, 11, 25, 3, 25, 3, 25, 3, 25, 5, 25, 727, 10, 25, 3, 25, 5, 25,
	730, 10, 25, 3, 25, 3, 25, 5, 25, 734, 10, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 743, 10, 25, 3, 26, 3, 26, 5, 26, 747,
	10, 26, 3, 27, 3, 27, 7, 27, 751, 10, 27, 12, 27, 14, 27, 754, 11, 27,
	3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 764, 10,
	28, 3, 28, 2, 4, 24, 38, 29, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
	26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 2, 12, 3, 2,
	79, 80, 3, 2, 21, 22, 4, 2, 54, 57, 93, 94, 3, 2, 101, 102, 3, 2, 98, 100,
	3, 2, 96, 97, 3, 2, 71, 72, 5, 2, 59, 62, 74, 78, 95, 95, 3, 2, 52, 53,
	3, 2, 3, 4, 2, 912, 2, 58, 3, 2, 2, 2, 4, 60, 3, 2, 2, 2, 6, 68, 3, 2,
	2, 2, 8, 71, 3, 2, 2, 2, 10, 295, 3, 2, 2, 2, 12, 300, 3, 2, 2, 2, 14,
	305, 3, 2, 2, 2, 16, 309, 3, 2, 2, 2, 18, 318, 3, 2, 2, 2, 20, 325, 3,
	2, 2, 2, 22, 329, 3, 2, 2, 2, 24, 393, 3, 2, 2, 2, 26, 470, 3, 2, 2, 2,
	28, 472, 3, 2, 2, 2, 30, 498, 3, 2, 2, 2, 32, 542, 3, 2, 2, 2, 34, 544,
	3, 2, 2, 2, 36, 547, 3, 2, 2, 2, 38, 550, 3, 2, 2, 2, 40, 571, 3, 2, 2,
	2, 42, 688, 3, 2, 2, 2, 44, 691, 3, 2, 2, 2, 46, 698, 3, 2, 2, 2, 48, 742,
	3, 2, 2, 2, 50, 746, 3, 2, 2, 2, 52, 748, 3, 2, 2, 2, 54, 763, 3, 2, 2,
	2, 56, 59, 5, 24, 13, 2, 57, 59, 5, 6, 4, 2, 58, 56, 3, 2, 2, 2, 58, 57,
	3, 2, 2, 2, 59, 3, 3, 2, 2, 2, 60, 61, 5, 6, 4, 2, 61, 5, 3, 2, 2, 2, 62,
	64, 5, 10, 6, 2, 63, 65, 7, 83, 2, 2, 64, 63, 3, 2, 2, 2, 64, 65, 3, 2,
	2, 2, 65, 67, 3, 2, 2, 2, 66, 62, 3, 2, 2, 2, 67, 70, 3, 2, 2, 2, 68, 66,
	3, 2, 2, 2, 68, 69, 3, 2, 2, 2, 69, 7, 3, 2, 2, 2, 70, 68, 3, 2, 2, 2,
	71, 72, 7, 87, 2, 2, 72, 73, 5, 6, 4, 2, 73, 74, 7, 88, 2, 2, 74, 9, 3,
	2, 2, 2, 75, 296, 5, 8, 5, 2, 76, 296, 5, 34, 18, 2, 77, 296, 5, 36, 19,
	2, 78, 296, 5, 32, 17, 2, 79, 296, 5, 16, 9, 2, 80, 81, 7, 12, 2, 2, 81,
	82, 7, 104, 2, 2, 82, 104, 7, 85, 2, 2, 83, 88, 7, 104, 2, 2, 84, 85, 7,
	82, 2, 2, 85, 87, 7, 104, 2, 2, 86, 84, 3, 2, 2, 2, 87, 90, 3, 2, 2, 2,
	88, 86, 3, 2, 2, 2, 88, 89, 3, 2, 2, 2, 89, 94, 3, 2, 2, 2, 90, 88, 3,
	2, 2, 2, 91, 92, 7, 82, 2, 2, 92, 93, 7, 48, 2, 2, 93, 95, 7, 104, 2, 2,
	94, 91, 3, 2, 2, 2, 94, 95, 3, 2, 2, 2, 95, 97, 3, 2, 2, 2, 96, 98, 7,
	82, 2, 2, 97, 96, 3, 2, 2, 2, 97, 98, 3, 2, 2, 2, 98, 105, 3, 2, 2, 2,
	99, 100, 7, 48, 2, 2, 100, 102, 7, 104, 2, 2, 101, 103, 7, 82, 2, 2, 102,
	101, 3, 2, 2, 2, 102, 103, 3, 2, 2, 2, 103, 105, 3, 2, 2, 2, 104, 83, 3,
	2, 2, 2, 104, 99, 3, 2, 2, 2, 104, 105, 3, 2, 2, 2, 105, 106, 3, 2, 2,
	2, 106, 107, 7, 86, 2, 2, 107, 296, 5, 8, 5, 2, 108, 110, 7, 19, 2, 2,
	109, 108, 3, 2, 2, 2, 109, 110, 3, 2, 2, 2, 110, 111, 3, 2, 2, 2, 111,
	112, 7, 20, 2, 2, 112, 121, 7, 104, 2, 2, 113, 114, 7, 85, 2, 2, 114, 117,
	5, 24, 13, 2, 115, 116, 7, 82, 2, 2, 116, 118, 5, 24, 13, 2, 117, 115,
	3, 2, 2, 2, 117, 118, 3, 2, 2, 2, 118, 119, 3, 2, 2, 2, 119, 120, 7, 86,
	2, 2, 120, 122, 3, 2, 2, 2, 121, 113, 3, 2, 2, 2, 121, 122, 3, 2, 2, 2,
	122, 123, 3, 2, 2, 2, 123, 127, 7, 87, 2, 2, 124, 126, 5, 14, 8, 2, 125,
	124, 3, 2, 2, 2, 126, 129, 3, 2, 2, 2, 127, 125, 3, 2, 2, 2, 127, 128,
	3, 2, 2, 2, 128, 130, 3, 2, 2, 2, 129, 127, 3, 2, 2, 2, 130, 296, 7, 88,
	2, 2, 131, 132, 7, 104, 2, 2, 132, 134, 7, 84, 2, 2, 133, 131, 3, 2, 2,
	2, 133, 134, 3, 2, 2, 2, 134, 135, 3, 2, 2, 2, 135, 136, 7, 5, 2, 2, 136,
	137, 5, 24, 13, 2, 137, 138, 7, 83, 2, 2, 138, 139, 5, 24, 13, 2, 139,
	140, 7, 83, 2, 2, 140, 141, 5, 24, 13, 2, 141, 142, 5, 8, 5, 2, 142, 296,
	3, 2, 2, 2, 143, 144, 7, 104, 2, 2, 144, 146, 7, 84, 2, 2, 145, 143, 3,
	2, 2, 2, 145, 146, 3, 2, 2, 2, 146, 147, 3, 2, 2, 2, 147, 150, 7, 5, 2,
	2, 148, 149, 7, 104, 2, 2, 149, 151, 7, 82, 2, 2, 150, 148, 3, 2, 2, 2,
	150, 151, 3, 2, 2, 2, 151, 152, 3, 2, 2, 2, 152, 153, 7, 104, 2, 2, 153,
	154, 7, 6, 2, 2, 154, 157, 5, 24, 13, 2, 155, 156, 9, 2, 2, 2, 156, 158,
	5, 24, 13, 2, 157, 155, 3, 2, 2, 2, 157, 158, 3, 2, 2, 2, 158, 159, 3,
	2, 2, 2, 159, 160, 5, 8, 5, 2, 160, 296, 3, 2, 2, 2, 161, 162, 7, 104,
	2, 2, 162, 164, 7, 84, 2, 2, 163, 161, 3, 2, 2, 2, 163, 164, 3, 2, 2, 2,
	164, 165, 3, 2, 2, 2, 165, 166, 7, 9, 2, 2, 166, 167, 5, 8, 5, 2, 167,
	168, 7, 8, 2, 2, 168, 169, 5, 24, 13, 2, 169, 296, 3, 2, 2, 2, 170, 171,
	7, 104, 2, 2, 171, 173, 7, 84, 2, 2, 172, 170, 3, 2, 2, 2, 172, 173, 3,
	2, 2, 2, 173, 174, 3, 2, 2, 2, 174, 175, 7, 8, 2, 2, 175, 176, 5, 24, 13,
	2, 176, 177, 5, 8, 5, 2, 177, 296, 3, 2, 2, 2, 178, 180, 7, 11, 2, 2, 179,
	181, 7, 104, 2, 2, 180, 179, 3, 2, 2, 2, 180, 181, 3, 2, 2, 2, 181, 296,
	3, 2, 2, 2, 182, 184, 7, 10, 2, 2, 183, 185, 7, 104, 2, 2, 184, 183, 3,
	2, 2, 2, 184, 185, 3, 2, 2, 2, 185, 296, 3, 2, 2, 2, 186, 187, 7, 7, 2,
	2, 187, 188, 5, 12, 7, 2, 188, 196, 5, 8, 5, 2, 189, 190, 7, 14, 2, 2,
	190, 191, 7, 7, 2, 2, 191, 192, 5, 12, 7, 2, 192, 193, 5, 8, 5, 2, 193,
	195, 3, 2, 2, 2, 194, 189, 3, 2, 2, 2, 195, 198, 3, 2, 2, 2, 196, 194,
	3, 2, 2, 2, 196, 197, 3, 2, 2, 2, 197, 201, 3, 2, 2, 2, 198, 196, 3, 2,
	2, 2, 199, 200, 7, 14, 2, 2, 200, 202, 5, 8, 5, 2, 201, 199, 3, 2, 2, 2,
	201, 202, 3, 2, 2, 2, 202, 296, 3, 2, 2, 2, 203, 204, 7, 32, 2, 2, 204,
	205, 5, 24, 13, 2, 205, 207, 7, 87, 2, 2, 206, 208, 5, 18, 10, 2, 207,
	206, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 207, 3, 2, 2, 2, 209, 210,
	3, 2, 2, 2, 210, 212, 3, 2, 2, 2, 211, 213, 5, 20, 11, 2, 212, 211, 3,
	2, 2, 2, 212, 213, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 215, 7, 88, 2,
	2, 215, 296, 3, 2, 2, 2, 216, 296, 7, 17, 2, 2, 217, 219, 7, 18, 2, 2,
	218, 220, 5, 24, 13, 2, 219, 218, 3, 2, 2, 2, 219, 220, 3, 2, 2, 2, 220,
	296, 3, 2, 2, 2, 221, 222, 7, 19, 2, 2, 222, 296, 7, 104, 2, 2, 223, 224,
	7, 19, 2, 2, 224, 225, 7, 104, 2, 2, 225, 226, 7, 58, 2, 2, 226, 296, 5,
	24, 13, 2, 227, 228, 7, 19, 2, 2, 228, 229, 7, 12, 2, 2, 229, 230, 7, 104,
	2, 2, 230, 249, 7, 85, 2, 2, 231, 236, 7, 104, 2, 2, 232, 233, 7, 82, 2,
	2, 233, 235, 7, 104, 2, 2, 234, 232, 3, 2, 2, 2, 235, 238, 3, 2, 2, 2,
	236, 234, 3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 242, 3, 2, 2, 2, 238,
	236, 3, 2, 2, 2, 239, 240, 7, 82, 2, 2, 240, 241, 7, 48, 2, 2, 241, 243,
	7, 104, 2, 2, 242, 239, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 245, 3,
	2, 2, 2, 244, 246, 7, 82, 2, 2, 245, 244, 3, 2, 2, 2, 245, 246, 3, 2, 2,
	2, 246, 250, 3, 2, 2, 2, 247, 248, 7, 48, 2, 2, 248, 250, 7, 104, 2, 2,
	249, 231, 3, 2, 2, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250,
	251, 3, 2, 2, 2, 251, 252, 7, 86, 2, 2, 252, 296, 5, 8, 5, 2, 253, 254,
	9, 3, 2, 2, 254, 256, 5, 24, 13, 2, 255, 257, 7, 66, 2, 2, 256, 255, 3,
	2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258, 259, 5, 28, 15,
	2, 259, 296, 3, 2, 2, 2, 260, 261, 7, 24, 2, 2, 261, 273, 5, 8, 5, 2, 262,
	263, 7, 25, 2, 2, 263, 264, 7, 85, 2, 2, 264, 265, 7, 104, 2, 2, 265, 266,
	7, 86, 2, 2, 266, 269, 5, 8, 5, 2, 267, 268, 7, 26, 2, 2, 268, 270, 5,
	8, 5, 2, 269, 267, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 274, 3, 2, 2,
	2, 271, 272, 7, 26, 2, 2, 272, 274, 5, 8, 5, 2, 273, 262, 3, 2, 2, 2, 273,
	271, 3, 2, 2, 2, 274, 296, 3, 2, 2, 2, 275, 276, 7, 28, 2, 2, 276, 279,
	5, 24, 13, 2, 277, 278, 7, 82, 2, 2, 278, 280, 5, 24, 13, 2, 279, 277,
	3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280, 296, 3, 2, 2, 2, 281, 283, 7, 19,
	2, 2, 282, 281, 3, 2, 2, 2, 282, 283, 3, 2, 2, 2, 283, 284, 3, 2, 2, 2,
	284, 285, 7, 29, 2, 2, 285, 286, 5, 24, 13, 2, 286, 290, 7, 87, 2, 2, 287,
	289, 5, 48, 25, 2, 288, 287, 3, 2, 2, 2, 289, 292, 3, 2, 2, 2, 290, 288,
	3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 291, 293, 3, 2, 2, 2, 292, 290, 3, 2,
	2, 2, 293, 294, 7, 88, 2, 2, 294, 296, 3, 2, 2, 2, 295, 75, 3, 2, 2, 2,
	295, 76, 3, 2, 2, 2, 295, 77, 3, 2, 2, 2, 295, 78, 3, 2, 2, 2, 295, 79,
	3, 2, 2, 2, 295, 80, 3, 2, 2, 2, 295, 109, 3, 2, 2, 2, 295, 133, 3, 2,
	2, 2, 295, 145, 3, 2, 2, 2, 295, 163, 3, 2, 2, 2, 295, 172, 3, 2, 2, 2,
	295, 178, 3, 2, 2, 2, 295, 182, 3, 2, 2, 2, 295, 186, 3, 2, 2, 2, 295,
	203, 3, 2, 2, 2, 295, 216, 3, 2, 2, 2, 295, 217, 3, 2, 2, 2, 295, 221,
	3, 2, 2, 2, 295, 223, 3, 2, 2, 2, 295, 227, 3, 2, 2, 2, 295, 253, 3, 2,
	2, 2, 295, 260, 3, 2, 2, 2, 295, 275, 3, 2, 2, 2, 295, 282, 3, 2, 2, 2,
	296, 11, 3, 2, 2, 2, 297, 298, 5, 32, 17, 2, 298, 299, 7, 83, 2, 2, 299,
	301, 3, 2, 2, 2, 300, 297, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 302,
	3, 2, 2, 2, 302, 303, 5, 24, 13, 2, 303, 13, 3, 2, 2, 2, 304, 306, 7, 27,
	2, 2, 305, 304, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2,
	307, 308, 5, 48, 25, 2, 308, 15, 3, 2, 2, 2, 309, 311, 5, 24, 13, 2, 310,
	312, 7, 66, 2, 2, 311, 310, 3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312, 313,
	3, 2, 2, 2, 313, 316, 5, 28, 15, 2, 314, 315, 7, 67, 2, 2, 315, 317, 5,
	8, 5, 2, 316, 314, 3, 2, 2, 2, 316, 317, 3, 2, 2, 2, 317, 17, 3, 2, 2,
	2, 318, 319, 7, 33, 2, 2, 319, 320, 5, 26, 14, 2, 320, 321, 7, 84, 2, 2,
	321, 323, 5, 6, 4, 2, 322, 324, 7, 34, 2, 2, 323, 322, 3, 2, 2, 2, 323,
	324, 3, 2, 2, 2, 324, 19, 3, 2, 2, 2, 325, 326, 7, 35, 2, 2, 326, 327,
	7, 84, 2, 2, 327, 328, 5, 6, 4, 2, 328, 21, 3, 2, 2, 2, 329, 330, 9, 4,
	2, 2, 330, 23, 3, 2, 2, 2, 331, 332, 8, 13, 1, 2, 332, 333, 9, 5, 2, 2,
	333, 394, 7, 104, 2, 2, 334, 394, 5, 34, 18, 2, 335, 394, 5, 36, 19, 2,
	336, 394, 7, 104, 2, 2, 337, 394, 5, 42, 22, 2, 338, 339, 7, 97, 2, 2,
	339, 394, 5, 24, 13, 25, 340, 341, 7, 91, 2, 2, 341, 394, 5, 24, 13, 24,
	342, 343, 7, 70, 2, 2, 343, 394, 5, 24, 13, 23, 344, 345, 7, 13, 2, 2,
	345, 350, 7, 87, 2, 2, 346, 347, 5, 24, 13, 2, 347, 348, 7, 49, 2, 2, 348,
	349, 5, 24, 13, 2, 349, 351, 3, 2, 2, 2, 350, 346, 3, 2, 2, 2, 351, 352,
	3, 2, 2, 2, 352, 350, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 357, 3, 2,
	2, 2, 354, 355, 7, 14, 2, 2, 355, 356, 7, 49, 2, 2, 356, 358, 5, 24, 13,
	2, 357, 354, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359,
	360, 7, 88, 2, 2, 360, 394, 3, 2, 2, 2, 361, 362, 7, 13, 2, 2, 362, 363,
	5, 24, 13, 2, 363, 368, 7, 87, 2, 2, 364, 365, 5, 26, 14, 2, 365, 366,
	7, 49, 2, 2, 366, 367, 5, 24, 13, 2, 367, 369, 3, 2, 2, 2, 368, 364, 3,
	2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 368, 3, 2, 2, 2, 370, 371, 3, 2, 2,
	2, 371, 375, 3, 2, 2, 2, 372, 373, 7, 14, 2, 2, 373, 374, 7, 49, 2, 2,
	374, 376, 5, 24, 13, 2, 375, 372, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376,
	377, 3, 2, 2, 2, 377, 378, 7, 88, 2, 2, 378, 394, 3, 2, 2, 2, 379, 394,
	5, 32, 17, 2, 380, 381, 7, 85, 2, 2, 381, 382, 5, 24, 13, 2, 382, 383,
	7, 86, 2, 2, 383, 394, 3, 2, 2, 2, 384, 385, 7, 30, 2, 2, 385, 386, 7,
	104, 2, 2, 386, 394, 5, 24, 13, 6, 387, 388, 7, 30, 2, 2, 388, 389, 5,
	8, 5, 2, 389, 390, 5, 24, 13, 5, 390, 394, 3, 2, 2, 2, 391, 392, 7, 31,
	2, 2, 392, 394, 5, 24, 13, 4, 393, 331, 3, 2, 2, 2, 393, 334, 3, 2, 2,
	2, 393, 335, 3, 2, 2, 2, 393, 336, 3, 2, 2, 2, 393, 337, 3, 2, 2, 2, 393,
	338, 3, 2, 2, 2, 393, 340, 3, 2, 2, 2, 393, 342, 3, 2, 2, 2, 393, 344,
	3, 2, 2, 2, 393, 361, 3, 2, 2, 2, 393, 379, 3, 2, 2, 2, 393, 380, 3, 2,
	2, 2, 393, 384, 3, 2, 2, 2, 393, 387, 3, 2, 2, 2, 393, 391, 3, 2, 2, 2,
	394, 452, 3, 2, 2, 2, 395, 396, 12, 22, 2, 2, 396, 397, 7, 51, 2, 2, 397,
	451, 5, 24, 13, 22, 398, 399, 12, 21, 2, 2, 399, 400, 9, 6, 2, 2, 400,
	451, 5, 24, 13, 22, 401, 402, 12, 20, 2, 2, 402, 403, 9, 7, 2, 2, 403,
	451, 5, 24, 13, 21, 404, 405, 12, 19, 2, 2, 405, 406, 9, 8, 2, 2, 406,
	451, 5, 24, 13, 20, 407, 408, 12, 18, 2, 2, 408, 409, 5, 22, 12, 2, 409,
	410, 5, 24, 13, 19, 410, 451, 3, 2, 2, 2, 411, 412, 12, 17, 2, 2, 412,
	413, 7, 68, 2, 2, 413, 451, 5, 24, 13, 18, 414, 415, 12, 16, 2, 2, 415,
	416, 7, 69, 2, 2, 416, 451, 5, 24, 13, 17, 417, 418, 12, 15, 2, 2, 418,
	419, 7, 73, 2, 2, 419, 451, 5, 24, 13, 16, 420, 421, 12, 14, 2, 2, 421,
	422, 7, 64, 2, 2, 422, 451, 5, 24, 13, 15, 423, 424, 12, 13, 2, 2, 424,
	425, 7, 65, 2, 2, 425, 451, 5, 24, 13, 14, 426, 427, 12, 10, 2, 2, 427,
	428, 7, 92, 2, 2, 428, 429, 5, 24, 13, 2, 429, 430, 7, 84, 2, 2, 430, 431,
	5, 24, 13, 11, 431, 451, 3, 2, 2, 2, 432, 433, 12, 9, 2, 2, 433, 434, 7,
	67, 2, 2, 434, 451, 5, 24, 13, 10, 435, 437, 12, 33, 2, 2, 436, 438, 7,
	66, 2, 2, 437, 436, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 439, 3, 2, 2,
	2, 439, 451, 5, 28, 15, 2, 440, 441, 12, 29, 2, 2, 441, 442, 7, 81, 2,
	2, 442, 451, 7, 104, 2, 2, 443, 444, 12, 28, 2, 2, 444, 445, 7, 89, 2,
	2, 445, 446, 5, 24, 13, 2, 446, 447, 7, 90, 2, 2, 447, 451, 3, 2, 2, 2,
	448, 449, 12, 3, 2, 2, 449, 451, 7, 91, 2, 2, 450, 395, 3, 2, 2, 2, 450,
	398, 3, 2, 2, 2, 450, 401, 3, 2, 2, 2, 450, 404, 3, 2, 2, 2, 450, 407,
	3, 2, 2, 2, 450, 411, 3, 2, 2, 2, 450, 414, 3, 2, 2, 2, 450, 417, 3, 2,
	2, 2, 450, 420, 3, 2, 2, 2, 450, 423, 3, 2, 2, 2, 450, 426, 3, 2, 2, 2,
	450, 432, 3, 2, 2, 2, 450, 435, 3, 2, 2, 2, 450, 440, 3, 2, 2, 2, 450,
	443, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 451, 454, 3, 2, 2, 2, 452, 450,
	3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 25, 3, 2, 2, 2, 454, 452, 3, 2,
	2, 2, 455, 460, 5, 24, 13, 2, 456, 457, 7, 82, 2, 2, 457, 459, 5, 24, 13,
	2, 458, 456, 3, 2, 2, 2, 459, 462, 3, 2, 2, 2, 460, 458, 3, 2, 2, 2, 460,
	461, 3, 2, 2, 2, 461, 471, 3, 2, 2, 2, 462, 460, 3, 2, 2, 2, 463, 465,
	5, 24, 13, 2, 464, 463, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 466, 3,
	2, 2, 2, 466, 468, 9, 2, 2, 2, 467, 469, 5, 24, 13, 2, 468, 467, 3, 2,
	2, 2, 468, 469, 3, 2, 2, 2, 469, 471, 3, 2, 2, 2, 470, 455, 3, 2, 2, 2,
	470, 464, 3, 2, 2, 2, 471, 27, 3, 2, 2, 2, 472, 484, 7, 85, 2, 2, 473,
	478, 5, 30, 16, 2, 474, 475, 7, 82, 2, 2, 475, 477, 5, 30, 16, 2, 476,
	474, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 478, 479,
	3, 2, 2, 2, 479, 482, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 481, 483, 7, 82,
	2, 2, 482, 481, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483, 485, 3, 2, 2, 2,
	484, 473, 3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 485, 486, 3, 2, 2, 2, 486,
	487, 7, 86, 2, 2, 487, 29, 3, 2, 2, 2, 488, 490, 7, 48, 2, 2, 489, 488,
	3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 494, 5, 24,
	13, 2, 492, 494, 5, 8, 5, 2, 493, 489, 3, 2, 2, 2, 493, 492, 3, 2, 2, 2,
	494, 499, 3, 2, 2, 2, 495, 496, 7, 104, 2, 2, 496, 497, 7, 84, 2, 2, 497,
	499, 5, 24, 13, 2, 498, 493, 3, 2, 2, 2, 498, 495, 3, 2, 2, 2, 499, 31,
	3, 2, 2, 2, 500, 501, 5, 38, 20, 2, 501, 502, 9, 9, 2, 2, 502, 503, 5,
	24, 13, 2, 503, 543, 3, 2, 2, 2, 504, 505, 7, 104, 2, 2, 505, 506, 7, 58,
	2, 2, 506, 543, 5, 24, 13, 2, 507, 508, 7, 89, 2, 2, 508, 513, 7, 104,
	2, 2, 509, 510, 7, 82, 2, 2, 510, 512, 7, 104, 2, 2, 511, 509, 3, 2, 2,
	2, 512, 515, 3, 2, 2, 2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514,
	519, 3, 2, 2, 2, 515, 513, 3, 2, 2, 2, 516, 517, 7, 82, 2, 2, 517, 518,
	7, 48, 2, 2, 518, 520, 7, 104, 2, 2, 519, 516, 3, 2, 2, 2, 519, 520, 3,
	2, 2, 2, 520, 522, 3, 2, 2, 2, 521, 523, 7, 82, 2, 2, 522, 521, 3, 2, 2,
	2, 522, 523, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 525, 7, 90, 2, 2, 525,
	526, 7, 58, 2, 2, 526, 543, 5, 24, 13, 2, 527, 528, 7, 87, 2, 2, 528, 533,
	7, 104, 2, 2, 529, 530, 7, 82, 2, 2, 530, 532, 7, 104, 2, 2, 531, 529,
	3, 2, 2, 2, 532, 535, 3, 2, 2, 2, 533, 531, 3, 2, 2, 2, 533, 534, 3, 2,
	2, 2, 534, 536, 3, 2, 2, 2, 535, 533, 3, 2, 2, 2, 536, 537, 7, 87, 2, 2,
	537, 538, 7, 58, 2, 2, 538, 543, 5, 24, 13, 2, 539, 540, 7, 48, 2, 2, 540,
	541, 7, 58, 2, 2, 541, 543, 5, 24, 13, 2, 542, 500, 3, 2, 2, 2, 542, 504,
	3, 2, 2, 2, 542, 507, 3, 2, 2, 2, 542, 527, 3, 2, 2, 2, 542, 539, 3, 2,
	2, 2, 543, 33, 3, 2, 2, 2, 544, 545, 9, 10, 2, 2, 545, 546, 5, 38, 20,
	2, 546, 35, 3, 2, 2, 2, 547, 548, 5, 38, 20, 2, 548, 549, 9, 10, 2, 2,
	549, 37, 3, 2, 2, 2, 550, 551, 8, 20, 1, 2, 551, 552, 7, 104, 2, 2, 552,
	563, 3, 2, 2, 2, 553, 554, 12, 5, 2, 2, 554, 555, 7, 81, 2, 2, 555, 562,
	7, 104, 2, 2, 556, 557, 12, 4, 2, 2, 557, 558, 7, 89, 2, 2, 558, 559, 5,
	24, 13, 2, 559, 560, 7, 90, 2, 2, 560, 562, 3, 2, 2, 2, 561, 553, 3, 2,
	2, 2, 561, 556, 3, 2, 2, 2, 562, 565, 3, 2, 2, 2, 563, 561, 3, 2, 2, 2,
	563, 564, 3, 2, 2, 2, 564, 39, 3, 2, 2, 2, 565, 563, 3, 2, 2, 2, 566, 572,
	7, 40, 2, 2, 567, 572, 7, 41, 2, 2, 568, 572, 7, 42, 2, 2, 569, 572, 7,
	43, 2, 2, 570, 572, 7, 44, 2, 2, 571, 566, 3, 2, 2, 2, 571, 567, 3, 2,
	2, 2, 571, 568, 3, 2, 2, 2, 571, 569, 3, 2, 2, 2, 571, 570, 3, 2, 2, 2,
	572, 41, 3, 2, 2, 2, 573, 689, 5, 40, 21, 2, 574, 689, 7, 46, 2, 2, 575,
	689, 7, 45, 2, 2, 576, 689, 9, 11, 2, 2, 577, 689, 5, 50, 26, 2, 578, 689,
	7, 15, 2, 2, 579, 689, 7, 16, 2, 2, 580, 581, 7, 12, 2, 2, 581, 600, 7,
	85, 2, 2, 582, 587, 7, 104, 2, 2, 583, 584, 7, 82, 2, 2, 584, 586, 7, 104,
	2, 2, 585, 583, 3, 2, 2, 2, 586, 589, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2,
	587, 588, 3, 2, 2, 2, 588, 593, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 590,
	591, 7, 82, 2, 2, 591, 592, 7, 48, 2, 2, 592, 594, 7, 104, 2, 2, 593, 590,
	3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 596, 3, 2, 2, 2, 595, 597, 7, 82,
	2, 2, 596, 595, 3, 2, 2, 2, 596, 597, 3, 2, 2, 2, 597, 601, 3, 2, 2, 2,
	598, 599, 7, 48, 2, 2, 599, 601, 7, 104, 2, 2, 600, 582, 3, 2, 2, 2, 600,
	598, 3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 603,
	7, 86, 2, 2, 603, 689, 5, 8, 5, 2, 604, 623, 7, 85, 2, 2, 605, 610, 7,
	104, 2, 2, 606, 607, 7, 82, 2, 2, 607, 609, 7, 104, 2, 2, 608, 606, 3,
	2, 2, 2, 609, 612, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 610, 611, 3, 2, 2,
	2, 611, 616, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 613, 614, 7, 82, 2, 2, 614,
	615, 7, 48, 2, 2, 615, 617, 7, 104, 2, 2, 616, 613, 3, 2, 2, 2, 616, 617,
	3, 2, 2, 2, 617, 619, 3, 2, 2, 2, 618, 620, 7, 82, 2, 2, 619, 618, 3, 2,
	2, 2, 619, 620, 3, 2, 2, 2, 620, 624, 3, 2, 2, 2, 621, 622, 7, 48, 2, 2,
	622, 624, 7, 104, 2, 2, 623, 605, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 623,
	624, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 628, 7, 86, 2, 2, 626, 628,
	7, 104, 2, 2, 627, 604, 3, 2, 2, 2, 627, 626, 3, 2, 2, 2, 628, 629, 3,
	2, 2, 2, 629, 630, 7, 50, 2, 2, 630, 689, 5, 24, 13, 2, 631, 650, 7, 85,
	2, 2, 632, 637, 7, 104, 2, 2, 633, 634, 7, 82, 2, 2, 634, 636, 7, 104,
	2, 2, 635, 633, 3, 2, 2, 2, 636, 639, 3, 2, 2, 2, 637, 635, 3, 2, 2, 2,
	637, 638, 3, 2, 2, 2, 638, 643, 3, 2, 2, 2, 639, 637, 3, 2, 2, 2, 640,
	641, 7, 82, 2, 2, 641, 642, 7, 48, 2, 2, 642, 644, 7, 104, 2, 2, 643, 640,
	3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 646, 3, 2, 2, 2, 645, 647, 7, 82,
	2, 2, 646, 645, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 651, 3, 2, 2, 2,
	648, 649, 7, 48, 2, 2, 649, 651, 7, 104, 2, 2, 650, 632, 3, 2, 2, 2, 650,
	648, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 3, 2, 2, 2, 652, 655,
	7, 86, 2, 2, 653, 655, 7, 104, 2, 2, 654, 631, 3, 2, 2, 2, 654, 653, 3,
	2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 657, 7, 50, 2, 2, 657, 689, 5, 8, 5,
	2, 658, 670, 7, 87, 2, 2, 659, 664, 5, 46, 24, 2, 660, 661, 7, 82, 2, 2,
	661, 663, 5, 46, 24, 2, 662, 660, 3, 2, 2, 2, 663, 666, 3, 2, 2, 2, 664,
	662, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665, 668, 3, 2, 2, 2, 666, 664,
	3, 2, 2, 2, 667, 669, 7, 82, 2, 2, 668, 667, 3, 2, 2, 2, 668, 669, 3, 2,
	2, 2, 669, 671, 3, 2, 2, 2, 670, 659, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2,
	671, 672, 3, 2, 2, 2, 672, 689, 7, 88, 2, 2, 673, 685, 7, 89, 2, 2, 674,
	679, 5, 44, 23, 2, 675, 676, 7, 82, 2, 2, 676, 678, 5, 44, 23, 2, 677,
	675, 3, 2, 2, 2, 678, 681, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 679, 680,
	3, 2, 2, 2, 680, 683, 3, 2, 2, 2, 681, 679, 3, 2, 2, 2, 682, 684, 7, 82,
	2, 2, 683, 682, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 686, 3, 2, 2, 2,
	685, 674, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 687, 3, 2, 2, 2, 687,
	689, 7, 90, 2, 2, 688, 573, 3, 2, 2, 2, 688, 574, 3, 2, 2, 2, 688, 575,
	3, 2, 2, 2, 688, 576, 3, 2, 2, 2, 688, 577, 3, 2, 2, 2, 688, 578, 3, 2,
	2, 2, 688, 579, 3, 2, 2, 2, 688, 580, 3, 2, 2, 2, 688, 627, 3, 2, 2, 2,
	688, 654, 3, 2, 2, 2, 688, 658, 3, 2, 2, 2, 688, 673, 3, 2, 2, 2, 689,
	43, 3, 2, 2, 2, 690, 692, 7, 48, 2, 2, 691, 690, 3, 2, 2, 2, 691, 692,
	3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 694, 5, 24, 13, 2, 694, 45, 3, 2,
	2, 2, 695, 699, 5, 48, 25, 2, 696, 697, 7, 48, 2, 2, 697, 699, 5, 24, 13,
	2, 698, 695, 3, 2, 2, 2, 698, 696, 3, 2, 2, 2, 699, 47, 3, 2, 2, 2, 700,
	701, 7, 104, 2, 2, 701, 702, 7, 84, 2, 2, 702, 743, 5, 24, 13, 2, 703,
	704, 5, 50, 26, 2, 704, 705, 7, 84, 2, 2, 705, 706, 5, 24, 13, 2, 706,
	743, 3, 2, 2, 2, 707, 708, 7, 89, 2, 2, 708, 709, 5, 24, 13, 2, 709, 710,
	7, 90, 2, 2, 710, 711, 7, 84, 2, 2, 711, 712, 5, 24, 13, 2, 712, 743, 3,
	2, 2, 2, 713, 714, 7, 104, 2, 2, 714, 733, 7, 85, 2, 2, 715, 720, 7, 104,
	2, 2, 716, 717, 7, 82, 2, 2, 717, 719, 7, 104, 2, 2, 718, 716, 3, 2, 2,
	2, 719, 722, 3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721,
	726, 3, 2, 2, 2, 722, 720, 3, 2, 2, 2, 723, 724, 7, 82, 2, 2, 724, 725,
	7, 48, 2, 2, 725, 727, 7, 104, 2, 2, 726, 723, 3, 2, 2, 2, 726, 727, 3,
	2, 2, 2, 727, 729, 3, 2, 2, 2, 728, 730, 7, 82, 2, 2, 729, 728, 3, 2, 2,
	2, 729, 730, 3, 2, 2, 2, 730, 734, 3, 2, 2, 2, 731, 732, 7, 48, 2, 2, 732,
	734, 7, 104, 2, 2, 733, 715, 3, 2, 2, 2, 733, 731, 3, 2, 2, 2, 733, 734,
	3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 736, 7, 86, 2, 2, 736, 743, 5, 8,
	5, 2, 737, 743, 7, 104, 2, 2, 738, 739, 7, 89, 2, 2, 739, 740, 5, 24, 13,
	2, 740, 741, 7, 90, 2, 2, 741, 743, 3, 2, 2, 2, 742, 700, 3, 2, 2, 2, 742,
	703, 3, 2, 2, 2, 742, 707, 3, 2, 2, 2, 742, 713, 3, 2, 2, 2, 742, 737,
	3, 2, 2, 2, 742, 738, 3, 2, 2, 2, 743, 49, 3, 2, 2, 2, 744, 747, 7, 47,
	2, 2, 745, 747, 5, 52, 27, 2, 746, 744, 3, 2, 2, 2, 746, 745, 3, 2, 2,
	2, 747, 51, 3, 2, 2, 2, 748, 752, 7, 103, 2, 2, 749, 751, 5, 54, 28, 2,
	750, 749, 3, 2, 2, 2, 751, 754, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 752,
	753, 3, 2, 2, 2, 753, 755, 3, 2, 2, 2, 754, 752, 3, 2, 2, 2, 755, 756,
	7, 103, 2, 2, 756, 53, 3, 2, 2, 2, 757, 764, 7, 105, 2, 2, 758, 764, 7,
	107, 2, 2, 759, 760, 7, 106, 2, 2, 760, 761, 5, 24, 13, 2, 761, 762, 7,
	88, 2, 2, 762, 764, 3, 2, 2, 2, 763, 757, 3, 2, 2, 2, 763, 758, 3, 2, 2,
	2, 763, 759, 3, 2, 2, 2, 764, 55, 3, 2, 2, 2, 100, 58, 64, 68, 88, 94,
	97, 102, 104, 109, 117, 121, 127, 133, 145, 150, 157, 163, 172, 180, 184,
	196, 201, 209, 212, 219, 236, 242, 245, 249, 256, 269, 273, 279, 282, 290,
	295, 300, 305, 311, 316, 323, 352, 357, 370, 375, 393, 437, 450, 452, 460,
	464, 468, 470, 478, 482, 484, 489, 493, 498, 513, 519, 522, 533, 542, 561,
	563, 571, 587, 593, 596, 600, 610, 616, 619, 623, 627, 637, 643, 646, 650,
	654, 664, 668, 670, 679, 683, 685, 688, 691, 698, 720, 726, 729, 733, 742,
	746, 752, 763,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'true'", "'false'", "'for'", "'in'", "'if'", "'while'", "'do'", "'break'",
	"'continue'", "'func'", "'when'", "'else'", "'nil'", "'undefined'", "",
	"'return'", "'export'", "'class'", "'defer'", "'blockDefer'", "'throw'",
	"'try'", "'catch'", "'finally'", "'static'", "'assert'", "'extend'", "'use@'",
	"'use'", "'switch'", "'case'", "'fallthrough'", "'default'", "", "", "",
	"", "'0'", "", "", "", "", "", "", "", "'...'", "'->'", "'=>'", "'**'",
	"'++'", "'--'", "'=='", "'!='", "'>='", "'<='", "':='", "'+='", "'-='",
	"'*='", "'/='", "'%='", "'&&'", "'||'", "'?.'", "'??'", "'&'", "'|'", "'~'",
	"'<<'", "'>>'", "'^'", "'&='", "'|='", "'<<='", "'>>='", "'^='", "'..<'",
	"'..'", "'.'", "','", "';'", "':'", "'('", "')'", "'{'", "'}'", "'['",
	"']'", "'!'", "'?'", "'>'", "'<'", "'='", "'+'", "'-'", "'*'", "'/'", "'%'",
	"'@'", "'@@'", "'''", "", "", "'${'",
}
var symbolicNames = []string{
	"", "TRUE", "FALSE", "FOR", "IN", "IF", "WHILE", "DO", "BREAK", "CONTINUE",
	"FUNC", "WHEN", "ELSE", "NIL", "UNDEFINED", "RETURN_NONE", "RETURN", "EXPORT",
	"CLASS", "DEFER", "BLOCK_DEFER", "THROW", "TRY", "CATCH", "FINALLY", "STATIC",
	"ASSERT", "EXTEND", "USE_AT", "USE", "SWITCH", "CASE", "FALLTHROUGH", "DEFAULT",
	"WS", "LINECOMMENT", "LINECOMMENT2", "BLOCKCOMMENT", "INT_ZERO", "INT_DEC",
	"INT_HEX", "INT_OCT", "INT_BIN", "BIGNUM", "FLOAT", "STRING", "MORE_ARGS",
	"LEAD_TO", "ARROW", "POW", "PLUS_PLUS", "MINUS_MINUS", "EQUAL", "NOT_EQUAL",
	"GTEQ", "LTEQ", "LOCAL_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "TIMES_ASSIGN",
	"DIV_ASSIGN", "MOD_ASSIGN", "LOGIC_AND", "LOGIC_OR", "OPTIONAL_CALL", "OPTIONAL_ELSE",
	"BIT_AND", "BIT_OR", "BIT_NOT", "BIT_SHL", "BIT_SHR", "BIT_XOR", "BIT_AND_ASSIGN",
	"BIT_OR_ASSIGN", "BIT_SHL_ASSIGN", "BIT_SHR_ASSIGN", "BIT_XOR_ASSIGN",
	"RANGE_WITHOUT_END", "RANGE_WITH_END", "DOT", "COMMA", "SEMICOLON", "COLON",
	"L_PAREN", "R_PAREN", "L_CURLY", "R_CURLY", "L_BRACKET", "R_BRACKET", "LOGIC_NOT",
	"QUESTION", "GT", "LT", "ASSIGN", "PLUS", "MINUS", "TIMES", "DIV", "MOD",
	"SINGLE_AT", "DOUBLE_AT", "QUOTE", "IDENTIFIER", "TS_RAW", "TS_EXPR_START",
	"TS_IDENTIFIER", "StrExpr_WS",
}

var ruleNames = []string{
	"replItem", "module", "block", "codeBlock", "stmt", "ifCondition", "memberDef",
	"callStmt", "switchCase", "switchDefault", "comparator", "expr", "whenCondition",
	"arguments", "funcArgument", "assignExpr", "preIncDec", "postIncDec", "lval",
	"integer", "literal", "arrayItem", "objItem", "keyValue", "stringLiteral",
	"templateString", "tsItem",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ZggParser struct {
	ZggBaseParser
}

func NewZggParser(input antlr.TokenStream) *ZggParser {
	this := new(ZggParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ZggParser.g4"

	return this
}

// ZggParser tokens.
const (
	ZggParserEOF               = antlr.TokenEOF
	ZggParserTRUE              = 1
	ZggParserFALSE             = 2
	ZggParserFOR               = 3
	ZggParserIN                = 4
	ZggParserIF                = 5
	ZggParserWHILE             = 6
	ZggParserDO                = 7
	ZggParserBREAK             = 8
	ZggParserCONTINUE          = 9
	ZggParserFUNC              = 10
	ZggParserWHEN              = 11
	ZggParserELSE              = 12
	ZggParserNIL               = 13
	ZggParserUNDEFINED         = 14
	ZggParserRETURN_NONE       = 15
	ZggParserRETURN            = 16
	ZggParserEXPORT            = 17
	ZggParserCLASS             = 18
	ZggParserDEFER             = 19
	ZggParserBLOCK_DEFER       = 20
	ZggParserTHROW             = 21
	ZggParserTRY               = 22
	ZggParserCATCH             = 23
	ZggParserFINALLY           = 24
	ZggParserSTATIC            = 25
	ZggParserASSERT            = 26
	ZggParserEXTEND            = 27
	ZggParserUSE_AT            = 28
	ZggParserUSE               = 29
	ZggParserSWITCH            = 30
	ZggParserCASE              = 31
	ZggParserFALLTHROUGH       = 32
	ZggParserDEFAULT           = 33
	ZggParserWS                = 34
	ZggParserLINECOMMENT       = 35
	ZggParserLINECOMMENT2      = 36
	ZggParserBLOCKCOMMENT      = 37
	ZggParserINT_ZERO          = 38
	ZggParserINT_DEC           = 39
	ZggParserINT_HEX           = 40
	ZggParserINT_OCT           = 41
	ZggParserINT_BIN           = 42
	ZggParserBIGNUM            = 43
	ZggParserFLOAT             = 44
	ZggParserSTRING            = 45
	ZggParserMORE_ARGS         = 46
	ZggParserLEAD_TO           = 47
	ZggParserARROW             = 48
	ZggParserPOW               = 49
	ZggParserPLUS_PLUS         = 50
	ZggParserMINUS_MINUS       = 51
	ZggParserEQUAL             = 52
	ZggParserNOT_EQUAL         = 53
	ZggParserGTEQ              = 54
	ZggParserLTEQ              = 55
	ZggParserLOCAL_ASSIGN      = 56
	ZggParserPLUS_ASSIGN       = 57
	ZggParserMINUS_ASSIGN      = 58
	ZggParserTIMES_ASSIGN      = 59
	ZggParserDIV_ASSIGN        = 60
	ZggParserMOD_ASSIGN        = 61
	ZggParserLOGIC_AND         = 62
	ZggParserLOGIC_OR          = 63
	ZggParserOPTIONAL_CALL     = 64
	ZggParserOPTIONAL_ELSE     = 65
	ZggParserBIT_AND           = 66
	ZggParserBIT_OR            = 67
	ZggParserBIT_NOT           = 68
	ZggParserBIT_SHL           = 69
	ZggParserBIT_SHR           = 70
	ZggParserBIT_XOR           = 71
	ZggParserBIT_AND_ASSIGN    = 72
	ZggParserBIT_OR_ASSIGN     = 73
	ZggParserBIT_SHL_ASSIGN    = 74
	ZggParserBIT_SHR_ASSIGN    = 75
	ZggParserBIT_XOR_ASSIGN    = 76
	ZggParserRANGE_WITHOUT_END = 77
	ZggParserRANGE_WITH_END    = 78
	ZggParserDOT               = 79
	ZggParserCOMMA             = 80
	ZggParserSEMICOLON         = 81
	ZggParserCOLON             = 82
	ZggParserL_PAREN           = 83
	ZggParserR_PAREN           = 84
	ZggParserL_CURLY           = 85
	ZggParserR_CURLY           = 86
	ZggParserL_BRACKET         = 87
	ZggParserR_BRACKET         = 88
	ZggParserLOGIC_NOT         = 89
	ZggParserQUESTION          = 90
	ZggParserGT                = 91
	ZggParserLT                = 92
	ZggParserASSIGN            = 93
	ZggParserPLUS              = 94
	ZggParserMINUS             = 95
	ZggParserTIMES             = 96
	ZggParserDIV               = 97
	ZggParserMOD               = 98
	ZggParserSINGLE_AT         = 99
	ZggParserDOUBLE_AT         = 100
	ZggParserQUOTE             = 101
	ZggParserIDENTIFIER        = 102
	ZggParserTS_RAW            = 103
	ZggParserTS_EXPR_START     = 104
	ZggParserTS_IDENTIFIER     = 105
	ZggParserStrExpr_WS        = 106
)

// ZggParser rules.
const (
	ZggParserRULE_replItem       = 0
	ZggParserRULE_module         = 1
	ZggParserRULE_block          = 2
	ZggParserRULE_codeBlock      = 3
	ZggParserRULE_stmt           = 4
	ZggParserRULE_ifCondition    = 5
	ZggParserRULE_memberDef      = 6
	ZggParserRULE_callStmt       = 7
	ZggParserRULE_switchCase     = 8
	ZggParserRULE_switchDefault  = 9
	ZggParserRULE_comparator     = 10
	ZggParserRULE_expr           = 11
	ZggParserRULE_whenCondition  = 12
	ZggParserRULE_arguments      = 13
	ZggParserRULE_funcArgument   = 14
	ZggParserRULE_assignExpr     = 15
	ZggParserRULE_preIncDec      = 16
	ZggParserRULE_postIncDec     = 17
	ZggParserRULE_lval           = 18
	ZggParserRULE_integer        = 19
	ZggParserRULE_literal        = 20
	ZggParserRULE_arrayItem      = 21
	ZggParserRULE_objItem        = 22
	ZggParserRULE_keyValue       = 23
	ZggParserRULE_stringLiteral  = 24
	ZggParserRULE_templateString = 25
	ZggParserRULE_tsItem         = 26
)

// IReplItemContext is an interface to support dynamic dispatch.
type IReplItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReplItemContext differentiates from other interfaces.
	IsReplItemContext()
}

type ReplItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplItemContext() *ReplItemContext {
	var p = new(ReplItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_replItem
	return p
}

func (*ReplItemContext) IsReplItemContext() {}

func NewReplItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplItemContext {
	var p = new(ReplItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_replItem

	return p
}

func (s *ReplItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplItemContext) CopyFrom(ctx *ReplItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ReplItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplBlockContext struct {
	*ReplItemContext
}

func NewReplBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplBlockContext {
	var p = new(ReplBlockContext)

	p.ReplItemContext = NewEmptyReplItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplItemContext))

	return p
}

func (s *ReplBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ReplBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitReplBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReplExprContext struct {
	*ReplItemContext
}

func NewReplExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplExprContext {
	var p = new(ReplExprContext)

	p.ReplItemContext = NewEmptyReplItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplItemContext))

	return p
}

func (s *ReplExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReplExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitReplExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ReplItem() (localctx IReplItemContext) {
	localctx = NewReplItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ZggParserRULE_replItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(56)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReplExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(54)
			p.expr(0)
		}

	case 2:
		localctx = NewReplBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(55)
			p.Block()
		}

	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ZggParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(58)
		p.Block()
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ZggParserSEMICOLON)
}

func (s *BlockContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ZggParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(66)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFOR)|(1<<ZggParserIF)|(1<<ZggParserWHILE)|(1<<ZggParserDO)|(1<<ZggParserBREAK)|(1<<ZggParserCONTINUE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserRETURN_NONE)|(1<<ZggParserRETURN)|(1<<ZggParserEXPORT)|(1<<ZggParserCLASS)|(1<<ZggParserDEFER)|(1<<ZggParserBLOCK_DEFER)|(1<<ZggParserTRY)|(1<<ZggParserASSERT)|(1<<ZggParserEXTEND)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE)|(1<<ZggParserSWITCH))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
		{
			p.SetState(60)
			p.Stmt()
		}
		p.SetState(62)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserSEMICOLON {
			{
				p.SetState(61)
				p.Match(ZggParserSEMICOLON)
			}

		}

		p.SetState(68)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_codeBlock
	return p
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *CodeBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CodeBlockContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ZggParserRULE_codeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(69)
		p.Match(ZggParserL_CURLY)
	}
	{
		p.SetState(70)
		p.Block()
	}
	{
		p.SetState(71)
		p.Match(ZggParserR_CURLY)
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyFrom(ctx *StmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StmtExtendContext struct {
	*StmtContext
}

func NewStmtExtendContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExtendContext {
	var p = new(StmtExtendContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExtendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExtendContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(ZggParserEXTEND, 0)
}

func (s *StmtExtendContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtExtendContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtExtendContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtExtendContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExtendContext) AllKeyValue() []IKeyValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyValueContext)(nil)).Elem())
	var tst = make([]IKeyValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyValueContext)
		}
	}

	return tst
}

func (s *StmtExtendContext) KeyValue(i int) IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *StmtExtendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExtend(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBreakContext struct {
	*StmtContext
	label antlr.Token
}

func NewStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBreakContext {
	var p = new(StmtBreakContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtBreakContext) GetLabel() antlr.Token { return s.label }

func (s *StmtBreakContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBreakContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ZggParserBREAK, 0)
}

func (s *StmtBreakContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtFuncCallContext struct {
	*StmtContext
}

func NewStmtFuncCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtFuncCallContext {
	var p = new(StmtFuncCallContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtFuncCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtFuncCallContext) CallStmt() ICallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallStmtContext)
}

func (s *StmtFuncCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFuncCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDoWhileContext struct {
	*StmtContext
	label     antlr.Token
	execBlock ICodeBlockContext
	checkExpr IExprContext
}

func NewStmtDoWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDoWhileContext {
	var p = new(StmtDoWhileContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtDoWhileContext) GetLabel() antlr.Token { return s.label }

func (s *StmtDoWhileContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtDoWhileContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtDoWhileContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtDoWhileContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtDoWhileContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtDoWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDoWhileContext) DO() antlr.TerminalNode {
	return s.GetToken(ZggParserDO, 0)
}

func (s *StmtDoWhileContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ZggParserWHILE, 0)
}

func (s *StmtDoWhileContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtDoWhileContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtDoWhileContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtDoWhileContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtDoWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtDoWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtAssertContext struct {
	*StmtContext
}

func NewStmtAssertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtAssertContext {
	var p = new(StmtAssertContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtAssertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtAssertContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(ZggParserASSERT, 0)
}

func (s *StmtAssertContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtAssertContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtAssertContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtAssertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtAssert(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDeferContext struct {
	*StmtContext
}

func NewStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDeferContext {
	var p = new(StmtDeferContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDeferContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtDeferContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *StmtDeferContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserDEFER, 0)
}

func (s *StmtDeferContext) BLOCK_DEFER() antlr.TerminalNode {
	return s.GetToken(ZggParserBLOCK_DEFER, 0)
}

func (s *StmtDeferContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *StmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtTryContext struct {
	*StmtContext
	tryBlock     ICodeBlockContext
	excName      antlr.Token
	catchBlock   ICodeBlockContext
	finallyBlock ICodeBlockContext
}

func NewStmtTryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtTryContext {
	var p = new(StmtTryContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtTryContext) GetExcName() antlr.Token { return s.excName }

func (s *StmtTryContext) SetExcName(v antlr.Token) { s.excName = v }

func (s *StmtTryContext) GetTryBlock() ICodeBlockContext { return s.tryBlock }

func (s *StmtTryContext) GetCatchBlock() ICodeBlockContext { return s.catchBlock }

func (s *StmtTryContext) GetFinallyBlock() ICodeBlockContext { return s.finallyBlock }

func (s *StmtTryContext) SetTryBlock(v ICodeBlockContext) { s.tryBlock = v }

func (s *StmtTryContext) SetCatchBlock(v ICodeBlockContext) { s.catchBlock = v }

func (s *StmtTryContext) SetFinallyBlock(v ICodeBlockContext) { s.finallyBlock = v }

func (s *StmtTryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtTryContext) TRY() antlr.TerminalNode {
	return s.GetToken(ZggParserTRY, 0)
}

func (s *StmtTryContext) AllCodeBlock() []ICodeBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem())
	var tst = make([]ICodeBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICodeBlockContext)
		}
	}

	return tst
}

func (s *StmtTryContext) CodeBlock(i int) ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtTryContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ZggParserCATCH, 0)
}

func (s *StmtTryContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtTryContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtTryContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ZggParserFINALLY, 0)
}

func (s *StmtTryContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtTryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtTry(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtContinueContext struct {
	*StmtContext
	label antlr.Token
}

func NewStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtContinueContext {
	var p = new(StmtContinueContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtContinueContext) GetLabel() antlr.Token { return s.label }

func (s *StmtContinueContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContinueContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ZggParserCONTINUE, 0)
}

func (s *StmtContinueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtSwitchContext struct {
	*StmtContext
	testValue IExprContext
}

func NewStmtSwitchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtSwitchContext {
	var p = new(StmtSwitchContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtSwitchContext) GetTestValue() IExprContext { return s.testValue }

func (s *StmtSwitchContext) SetTestValue(v IExprContext) { s.testValue = v }

func (s *StmtSwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtSwitchContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ZggParserSWITCH, 0)
}

func (s *StmtSwitchContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtSwitchContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtSwitchContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtSwitchContext) AllSwitchCase() []ISwitchCaseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem())
	var tst = make([]ISwitchCaseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchCaseContext)
		}
	}

	return tst
}

func (s *StmtSwitchContext) SwitchCase(i int) ISwitchCaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseContext)
}

func (s *StmtSwitchContext) SwitchDefault() ISwitchDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchDefaultContext)
}

func (s *StmtSwitchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtSwitch(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportFuncDefineContext struct {
	*StmtContext
}

func NewStmtExportFuncDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportFuncDefineContext {
	var p = new(StmtExportFuncDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportFuncDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportFuncDefineContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportFuncDefineContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *StmtExportFuncDefineContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtExportFuncDefineContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtExportFuncDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtExportFuncDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtExportFuncDefineContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtExportFuncDefineContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *StmtExportFuncDefineContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *StmtExportFuncDefineContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *StmtExportFuncDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportFuncDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBlockContext struct {
	*StmtContext
}

func NewStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBlockContext {
	var p = new(StmtBlockContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtPreIncDecContext struct {
	*StmtContext
}

func NewStmtPreIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtPreIncDecContext {
	var p = new(StmtPreIncDecContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtPreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtPreIncDecContext) PreIncDec() IPreIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncDecContext)
}

func (s *StmtPreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtClassDefineContext struct {
	*StmtContext
	className antlr.Token
	_expr     IExprContext
	baseCls   []IExprContext
}

func NewStmtClassDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtClassDefineContext {
	var p = new(StmtClassDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtClassDefineContext) GetClassName() antlr.Token { return s.className }

func (s *StmtClassDefineContext) SetClassName(v antlr.Token) { s.className = v }

func (s *StmtClassDefineContext) Get_expr() IExprContext { return s._expr }

func (s *StmtClassDefineContext) Set_expr(v IExprContext) { s._expr = v }

func (s *StmtClassDefineContext) GetBaseCls() []IExprContext { return s.baseCls }

func (s *StmtClassDefineContext) SetBaseCls(v []IExprContext) { s.baseCls = v }

func (s *StmtClassDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtClassDefineContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ZggParserCLASS, 0)
}

func (s *StmtClassDefineContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *StmtClassDefineContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *StmtClassDefineContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtClassDefineContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtClassDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtClassDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtClassDefineContext) AllMemberDef() []IMemberDefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberDefContext)(nil)).Elem())
	var tst = make([]IMemberDefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberDefContext)
		}
	}

	return tst
}

func (s *StmtClassDefineContext) MemberDef(i int) IMemberDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberDefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberDefContext)
}

func (s *StmtClassDefineContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtClassDefineContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtClassDefineContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtClassDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtClassDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportIdentifierContext struct {
	*StmtContext
}

func NewStmtExportIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportIdentifierContext {
	var p = new(StmtExportIdentifierContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportIdentifierContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtExportIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtWhileContext struct {
	*StmtContext
	label     antlr.Token
	checkExpr IExprContext
	execBlock ICodeBlockContext
}

func NewStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtWhileContext {
	var p = new(StmtWhileContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtWhileContext) GetLabel() antlr.Token { return s.label }

func (s *StmtWhileContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtWhileContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtWhileContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtWhileContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtWhileContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtWhileContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ZggParserWHILE, 0)
}

func (s *StmtWhileContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtWhileContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtWhileContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtWhileContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtFuncDefineContext struct {
	*StmtContext
}

func NewStmtFuncDefineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtFuncDefineContext {
	var p = new(StmtFuncDefineContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtFuncDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtFuncDefineContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *StmtFuncDefineContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtFuncDefineContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtFuncDefineContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *StmtFuncDefineContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *StmtFuncDefineContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtFuncDefineContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *StmtFuncDefineContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *StmtFuncDefineContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *StmtFuncDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFuncDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtForContext struct {
	*StmtContext
	label     antlr.Token
	initExpr  IExprContext
	checkExpr IExprContext
	nextExpr  IExprContext
	execBlock ICodeBlockContext
}

func NewStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtForContext {
	var p = new(StmtForContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtForContext) GetLabel() antlr.Token { return s.label }

func (s *StmtForContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtForContext) GetInitExpr() IExprContext { return s.initExpr }

func (s *StmtForContext) GetCheckExpr() IExprContext { return s.checkExpr }

func (s *StmtForContext) GetNextExpr() IExprContext { return s.nextExpr }

func (s *StmtForContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtForContext) SetInitExpr(v IExprContext) { s.initExpr = v }

func (s *StmtForContext) SetCheckExpr(v IExprContext) { s.checkExpr = v }

func (s *StmtForContext) SetNextExpr(v IExprContext) { s.nextExpr = v }

func (s *StmtForContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtForContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *StmtForContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ZggParserSEMICOLON)
}

func (s *StmtForContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, i)
}

func (s *StmtForContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtForContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtForContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtForContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtForContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtForEachContext struct {
	*StmtContext
	label     antlr.Token
	idIndex   antlr.Token
	idValue   antlr.Token
	begin     IExprContext
	end       IExprContext
	execBlock ICodeBlockContext
}

func NewStmtForEachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtForEachContext {
	var p = new(StmtForEachContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtForEachContext) GetLabel() antlr.Token { return s.label }

func (s *StmtForEachContext) GetIdIndex() antlr.Token { return s.idIndex }

func (s *StmtForEachContext) GetIdValue() antlr.Token { return s.idValue }

func (s *StmtForEachContext) SetLabel(v antlr.Token) { s.label = v }

func (s *StmtForEachContext) SetIdIndex(v antlr.Token) { s.idIndex = v }

func (s *StmtForEachContext) SetIdValue(v antlr.Token) { s.idValue = v }

func (s *StmtForEachContext) GetBegin() IExprContext { return s.begin }

func (s *StmtForEachContext) GetEnd() IExprContext { return s.end }

func (s *StmtForEachContext) GetExecBlock() ICodeBlockContext { return s.execBlock }

func (s *StmtForEachContext) SetBegin(v IExprContext) { s.begin = v }

func (s *StmtForEachContext) SetEnd(v IExprContext) { s.end = v }

func (s *StmtForEachContext) SetExecBlock(v ICodeBlockContext) { s.execBlock = v }

func (s *StmtForEachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtForEachContext) FOR() antlr.TerminalNode {
	return s.GetToken(ZggParserFOR, 0)
}

func (s *StmtForEachContext) IN() antlr.TerminalNode {
	return s.GetToken(ZggParserIN, 0)
}

func (s *StmtForEachContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *StmtForEachContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *StmtForEachContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *StmtForEachContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtForEachContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtForEachContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *StmtForEachContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, 0)
}

func (s *StmtForEachContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *StmtForEachContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *StmtForEachContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtForEach(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtIfContext struct {
	*StmtContext
}

func NewStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtIfContext {
	var p = new(StmtIfContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtIfContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIF)
}

func (s *StmtIfContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIF, i)
}

func (s *StmtIfContext) AllIfCondition() []IIfConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIfConditionContext)(nil)).Elem())
	var tst = make([]IIfConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIfConditionContext)
		}
	}

	return tst
}

func (s *StmtIfContext) IfCondition(i int) IIfConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIfConditionContext)
}

func (s *StmtIfContext) AllCodeBlock() []ICodeBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem())
	var tst = make([]ICodeBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICodeBlockContext)
		}
	}

	return tst
}

func (s *StmtIfContext) CodeBlock(i int) ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtIfContext) AllELSE() []antlr.TerminalNode {
	return s.GetTokens(ZggParserELSE)
}

func (s *StmtIfContext) ELSE(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, i)
}

func (s *StmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtReturnNoneContext struct {
	*StmtContext
}

func NewStmtReturnNoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtReturnNoneContext {
	var p = new(StmtReturnNoneContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtReturnNoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtReturnNoneContext) RETURN_NONE() antlr.TerminalNode {
	return s.GetToken(ZggParserRETURN_NONE, 0)
}

func (s *StmtReturnNoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtReturnNone(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExportExprContext struct {
	*StmtContext
}

func NewStmtExportExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExportExprContext {
	var p = new(StmtExportExprContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtExportExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExportExprContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ZggParserEXPORT, 0)
}

func (s *StmtExportExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *StmtExportExprContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *StmtExportExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtExportExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtExportExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtReturnContext struct {
	*StmtContext
}

func NewStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtReturnContext {
	var p = new(StmtReturnContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ZggParserRETURN, 0)
}

func (s *StmtReturnContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtPostIncDecContext struct {
	*StmtContext
}

func NewStmtPostIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtPostIncDecContext {
	var p = new(StmtPostIncDecContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtPostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtPostIncDecContext) PostIncDec() IPostIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostIncDecContext)
}

func (s *StmtPostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtAssignContext struct {
	*StmtContext
}

func NewStmtAssignContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtAssignContext {
	var p = new(StmtAssignContext)

	p.StmtContext = NewEmptyStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StmtContext))

	return p
}

func (s *StmtAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtAssignContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *StmtAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStmtAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ZggParserRULE_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(73)
			p.CodeBlock()
		}

	case 2:
		localctx = NewStmtPreIncDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(74)
			p.PreIncDec()
		}

	case 3:
		localctx = NewStmtPostIncDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(75)
			p.PostIncDec()
		}

	case 4:
		localctx = NewStmtAssignContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(76)
			p.AssignExpr()
		}

	case 5:
		localctx = NewStmtFuncCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(77)
			p.CallStmt()
		}

	case 6:
		localctx = NewStmtFuncDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(78)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(79)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(80)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(102)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(81)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(86)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(82)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(83)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(88)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
			}
			p.SetState(92)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(89)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(90)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(91)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(95)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(94)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(97)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(98)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(100)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(99)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(104)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(105)
			p.CodeBlock()
		}

	case 7:
		localctx = NewStmtClassDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserEXPORT {
			{
				p.SetState(106)
				p.Match(ZggParserEXPORT)
			}

		}
		{
			p.SetState(109)
			p.Match(ZggParserCLASS)
		}
		{
			p.SetState(110)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*StmtClassDefineContext).className = _m
		}
		p.SetState(119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserL_PAREN {
			{
				p.SetState(111)
				p.Match(ZggParserL_PAREN)
			}
			{
				p.SetState(112)

				var _x = p.expr(0)

				localctx.(*StmtClassDefineContext)._expr = _x
			}
			localctx.(*StmtClassDefineContext).baseCls = append(localctx.(*StmtClassDefineContext).baseCls, localctx.(*StmtClassDefineContext)._expr)
			p.SetState(115)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(113)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(114)

					var _x = p.expr(0)

					localctx.(*StmtClassDefineContext)._expr = _x
				}
				localctx.(*StmtClassDefineContext).baseCls = append(localctx.(*StmtClassDefineContext).baseCls, localctx.(*StmtClassDefineContext)._expr)

			}
			{
				p.SetState(117)
				p.Match(ZggParserR_PAREN)
			}

		}
		{
			p.SetState(121)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserSTATIC || _la == ZggParserSTRING || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(ZggParserL_BRACKET-87))|(1<<(ZggParserQUOTE-87))|(1<<(ZggParserIDENTIFIER-87)))) != 0) {
			{
				p.SetState(122)
				p.MemberDef()
			}

			p.SetState(127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(128)
			p.Match(ZggParserR_CURLY)
		}

	case 8:
		localctx = NewStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(129)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForContext).label = _m
			}
			{
				p.SetState(130)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(133)
			p.Match(ZggParserFOR)
		}
		{
			p.SetState(134)

			var _x = p.expr(0)

			localctx.(*StmtForContext).initExpr = _x
		}
		{
			p.SetState(135)
			p.Match(ZggParserSEMICOLON)
		}
		{
			p.SetState(136)

			var _x = p.expr(0)

			localctx.(*StmtForContext).checkExpr = _x
		}
		{
			p.SetState(137)
			p.Match(ZggParserSEMICOLON)
		}
		{
			p.SetState(138)

			var _x = p.expr(0)

			localctx.(*StmtForContext).nextExpr = _x
		}
		{
			p.SetState(139)

			var _x = p.CodeBlock()

			localctx.(*StmtForContext).execBlock = _x
		}

	case 9:
		localctx = NewStmtForEachContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(141)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForEachContext).label = _m
			}
			{
				p.SetState(142)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(145)
			p.Match(ZggParserFOR)
		}
		p.SetState(148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(146)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtForEachContext).idIndex = _m
			}
			{
				p.SetState(147)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(150)

			var _m = p.Match(ZggParserIDENTIFIER)

			localctx.(*StmtForEachContext).idValue = _m
		}
		{
			p.SetState(151)
			p.Match(ZggParserIN)
		}
		{
			p.SetState(152)

			var _x = p.expr(0)

			localctx.(*StmtForEachContext).begin = _x
		}
		p.SetState(155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END {
			{
				p.SetState(153)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(154)

				var _x = p.expr(0)

				localctx.(*StmtForEachContext).end = _x
			}

		}
		{
			p.SetState(157)

			var _x = p.CodeBlock()

			localctx.(*StmtForEachContext).execBlock = _x
		}

	case 10:
		localctx = NewStmtDoWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(159)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtDoWhileContext).label = _m
			}
			{
				p.SetState(160)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(163)
			p.Match(ZggParserDO)
		}
		{
			p.SetState(164)

			var _x = p.CodeBlock()

			localctx.(*StmtDoWhileContext).execBlock = _x
		}
		{
			p.SetState(165)
			p.Match(ZggParserWHILE)
		}
		{
			p.SetState(166)

			var _x = p.expr(0)

			localctx.(*StmtDoWhileContext).checkExpr = _x
		}

	case 11:
		localctx = NewStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserIDENTIFIER {
			{
				p.SetState(168)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtWhileContext).label = _m
			}
			{
				p.SetState(169)
				p.Match(ZggParserCOLON)
			}

		}
		{
			p.SetState(172)
			p.Match(ZggParserWHILE)
		}
		{
			p.SetState(173)

			var _x = p.expr(0)

			localctx.(*StmtWhileContext).checkExpr = _x
		}
		{
			p.SetState(174)

			var _x = p.CodeBlock()

			localctx.(*StmtWhileContext).execBlock = _x
		}

	case 12:
		localctx = NewStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(176)
			p.Match(ZggParserCONTINUE)
		}
		p.SetState(178)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(177)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtContinueContext).label = _m
			}

		}

	case 13:
		localctx = NewStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(180)
			p.Match(ZggParserBREAK)
		}
		p.SetState(182)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(181)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtBreakContext).label = _m
			}

		}

	case 14:
		localctx = NewStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(184)
			p.Match(ZggParserIF)
		}
		{
			p.SetState(185)
			p.IfCondition()
		}
		{
			p.SetState(186)
			p.CodeBlock()
		}
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(187)
					p.Match(ZggParserELSE)
				}
				{
					p.SetState(188)
					p.Match(ZggParserIF)
				}
				{
					p.SetState(189)
					p.IfCondition()
				}
				{
					p.SetState(190)
					p.CodeBlock()
				}

			}
			p.SetState(196)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(197)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(198)
				p.CodeBlock()
			}

		}

	case 15:
		localctx = NewStmtSwitchContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(201)
			p.Match(ZggParserSWITCH)
		}
		{
			p.SetState(202)

			var _x = p.expr(0)

			localctx.(*StmtSwitchContext).testValue = _x
		}
		{
			p.SetState(203)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ZggParserCASE {
			{
				p.SetState(204)
				p.SwitchCase()
			}

			p.SetState(207)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserDEFAULT {
			{
				p.SetState(209)
				p.SwitchDefault()
			}

		}
		{
			p.SetState(212)
			p.Match(ZggParserR_CURLY)
		}

	case 16:
		localctx = NewStmtReturnNoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(214)
			p.Match(ZggParserRETURN_NONE)
		}

	case 17:
		localctx = NewStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(215)
			p.Match(ZggParserRETURN)
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(216)
				p.expr(0)
			}

		}

	case 18:
		localctx = NewStmtExportIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(219)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(220)
			p.Match(ZggParserIDENTIFIER)
		}

	case 19:
		localctx = NewStmtExportExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(221)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(222)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(223)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(224)
			p.expr(0)
		}

	case 20:
		localctx = NewStmtExportFuncDefineContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(225)
			p.Match(ZggParserEXPORT)
		}
		{
			p.SetState(226)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(227)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(228)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(229)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(234)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(230)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(231)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(236)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
			}
			p.SetState(240)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(237)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(238)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(239)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(243)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(242)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(245)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(246)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(249)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(250)
			p.CodeBlock()
		}

	case 21:
		localctx = NewStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(251)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserDEFER || _la == ZggParserBLOCK_DEFER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(252)
			p.expr(0)
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserOPTIONAL_CALL {
			{
				p.SetState(253)
				p.Match(ZggParserOPTIONAL_CALL)
			}

		}
		{
			p.SetState(256)
			p.Arguments()
		}

	case 22:
		localctx = NewStmtTryContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(258)
			p.Match(ZggParserTRY)
		}
		{
			p.SetState(259)

			var _x = p.CodeBlock()

			localctx.(*StmtTryContext).tryBlock = _x
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserCATCH:
			{
				p.SetState(260)
				p.Match(ZggParserCATCH)
			}
			{
				p.SetState(261)
				p.Match(ZggParserL_PAREN)
			}
			{
				p.SetState(262)

				var _m = p.Match(ZggParserIDENTIFIER)

				localctx.(*StmtTryContext).excName = _m
			}
			{
				p.SetState(263)
				p.Match(ZggParserR_PAREN)
			}
			{
				p.SetState(264)

				var _x = p.CodeBlock()

				localctx.(*StmtTryContext).catchBlock = _x
			}
			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserFINALLY {
				{
					p.SetState(265)
					p.Match(ZggParserFINALLY)
				}
				{
					p.SetState(266)

					var _x = p.CodeBlock()

					localctx.(*StmtTryContext).finallyBlock = _x
				}

			}

		case ZggParserFINALLY:
			{
				p.SetState(269)
				p.Match(ZggParserFINALLY)
			}
			{
				p.SetState(270)

				var _x = p.CodeBlock()

				localctx.(*StmtTryContext).finallyBlock = _x
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 23:
		localctx = NewStmtAssertContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(273)
			p.Match(ZggParserASSERT)
		}
		{
			p.SetState(274)
			p.expr(0)
		}
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(275)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(276)
				p.expr(0)
			}

		}

	case 24:
		localctx = NewStmtExtendContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserEXPORT {
			{
				p.SetState(279)
				p.Match(ZggParserEXPORT)
			}

		}
		{
			p.SetState(282)
			p.Match(ZggParserEXTEND)
		}
		{
			p.SetState(283)
			p.expr(0)
		}
		{
			p.SetState(284)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserSTRING || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(ZggParserL_BRACKET-87))|(1<<(ZggParserQUOTE-87))|(1<<(ZggParserIDENTIFIER-87)))) != 0) {
			{
				p.SetState(285)
				p.KeyValue()
			}

			p.SetState(290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(291)
			p.Match(ZggParserR_CURLY)
		}

	}

	return localctx
}

// IIfConditionContext is an interface to support dynamic dispatch.
type IIfConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfConditionContext differentiates from other interfaces.
	IsIfConditionContext()
}

type IfConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionContext() *IfConditionContext {
	var p = new(IfConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_ifCondition
	return p
}

func (*IfConditionContext) IsIfConditionContext() {}

func NewIfConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionContext {
	var p = new(IfConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_ifCondition

	return p
}

func (s *IfConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfConditionContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *IfConditionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ZggParserSEMICOLON, 0)
}

func (s *IfConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIfCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) IfCondition() (localctx IIfConditionContext) {
	localctx = NewIfConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ZggParserRULE_ifCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(295)
			p.AssignExpr()
		}
		{
			p.SetState(296)
			p.Match(ZggParserSEMICOLON)
		}

	}
	{
		p.SetState(300)
		p.expr(0)
	}

	return localctx
}

// IMemberDefContext is an interface to support dynamic dispatch.
type IMemberDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberDefContext differentiates from other interfaces.
	IsMemberDefContext()
}

type MemberDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDefContext() *MemberDefContext {
	var p = new(MemberDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_memberDef
	return p
}

func (*MemberDefContext) IsMemberDefContext() {}

func NewMemberDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDefContext {
	var p = new(MemberDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_memberDef

	return p
}

func (s *MemberDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDefContext) KeyValue() IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *MemberDefContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ZggParserSTATIC, 0)
}

func (s *MemberDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitMemberDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) MemberDef() (localctx IMemberDefContext) {
	localctx = NewMemberDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ZggParserRULE_memberDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserSTATIC {
		{
			p.SetState(302)
			p.Match(ZggParserSTATIC)
		}

	}
	{
		p.SetState(305)
		p.KeyValue()
	}

	return localctx
}

// ICallStmtContext is an interface to support dynamic dispatch.
type ICallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStmtContext differentiates from other interfaces.
	IsCallStmtContext()
}

type CallStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStmtContext() *CallStmtContext {
	var p = new(CallStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_callStmt
	return p
}

func (*CallStmtContext) IsCallStmtContext() {}

func NewCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStmtContext {
	var p = new(CallStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_callStmt

	return p
}

func (s *CallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CallStmtContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *CallStmtContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *CallStmtContext) OPTIONAL_ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_ELSE, 0)
}

func (s *CallStmtContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitCallStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) CallStmt() (localctx ICallStmtContext) {
	localctx = NewCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ZggParserRULE_callStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(307)
		p.expr(0)
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserOPTIONAL_CALL {
		{
			p.SetState(308)
			p.Match(ZggParserOPTIONAL_CALL)
		}

	}
	{
		p.SetState(311)
		p.Arguments()
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserOPTIONAL_ELSE {
		{
			p.SetState(312)
			p.Match(ZggParserOPTIONAL_ELSE)
		}
		{
			p.SetState(313)
			p.CodeBlock()
		}

	}

	return localctx
}

// ISwitchCaseContext is an interface to support dynamic dispatch.
type ISwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchCaseContext differentiates from other interfaces.
	IsSwitchCaseContext()
}

type SwitchCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseContext() *SwitchCaseContext {
	var p = new(SwitchCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_switchCase
	return p
}

func (*SwitchCaseContext) IsSwitchCaseContext() {}

func NewSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseContext {
	var p = new(SwitchCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_switchCase

	return p
}

func (s *SwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ZggParserCASE, 0)
}

func (s *SwitchCaseContext) WhenCondition() IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *SwitchCaseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *SwitchCaseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchCaseContext) FALLTHROUGH() antlr.TerminalNode {
	return s.GetToken(ZggParserFALLTHROUGH, 0)
}

func (s *SwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) SwitchCase() (localctx ISwitchCaseContext) {
	localctx = NewSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ZggParserRULE_switchCase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Match(ZggParserCASE)
	}
	{
		p.SetState(317)
		p.WhenCondition()
	}
	{
		p.SetState(318)
		p.Match(ZggParserCOLON)
	}
	{
		p.SetState(319)
		p.Block()
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ZggParserFALLTHROUGH {
		{
			p.SetState(320)
			p.Match(ZggParserFALLTHROUGH)
		}

	}

	return localctx
}

// ISwitchDefaultContext is an interface to support dynamic dispatch.
type ISwitchDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchDefaultContext differentiates from other interfaces.
	IsSwitchDefaultContext()
}

type SwitchDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchDefaultContext() *SwitchDefaultContext {
	var p = new(SwitchDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_switchDefault
	return p
}

func (*SwitchDefaultContext) IsSwitchDefaultContext() {}

func NewSwitchDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchDefaultContext {
	var p = new(SwitchDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_switchDefault

	return p
}

func (s *SwitchDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ZggParserDEFAULT, 0)
}

func (s *SwitchDefaultContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *SwitchDefaultContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitSwitchDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) SwitchDefault() (localctx ISwitchDefaultContext) {
	localctx = NewSwitchDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ZggParserRULE_switchDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(323)
		p.Match(ZggParserDEFAULT)
	}
	{
		p.SetState(324)
		p.Match(ZggParserCOLON)
	}
	{
		p.SetState(325)
		p.Block()
	}

	return localctx
}

// IComparatorContext is an interface to support dynamic dispatch.
type IComparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparatorContext differentiates from other interfaces.
	IsComparatorContext()
}

type ComparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparatorContext() *ComparatorContext {
	var p = new(ComparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_comparator
	return p
}

func (*ComparatorContext) IsComparatorContext() {}

func NewComparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparatorContext {
	var p = new(ComparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_comparator

	return p
}

func (s *ComparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ZggParserEQUAL, 0)
}

func (s *ComparatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(ZggParserNOT_EQUAL, 0)
}

func (s *ComparatorContext) GTEQ() antlr.TerminalNode {
	return s.GetToken(ZggParserGTEQ, 0)
}

func (s *ComparatorContext) LTEQ() antlr.TerminalNode {
	return s.GetToken(ZggParserLTEQ, 0)
}

func (s *ComparatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ZggParserLT, 0)
}

func (s *ComparatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ZggParserGT, 0)
}

func (s *ComparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitComparator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Comparator() (localctx IComparatorContext) {
	localctx = NewComparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ZggParserRULE_comparator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(ZggParserEQUAL-52))|(1<<(ZggParserNOT_EQUAL-52))|(1<<(ZggParserGTEQ-52))|(1<<(ZggParserLTEQ-52)))) != 0) || _la == ZggParserGT || _la == ZggParserLT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyFrom(ctx *ExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExprPlusMinusContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprPlusMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPlusMinusContext {
	var p = new(ExprPlusMinusContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPlusMinusContext) GetOp() antlr.Token { return s.op }

func (s *ExprPlusMinusContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprPlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPlusMinusContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprPlusMinusContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprPlusMinusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS, 0)
}

func (s *ExprPlusMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS, 0)
}

func (s *ExprPlusMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPlusMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseCloserContext struct {
	*ExprContext
}

func NewExprUseCloserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseCloserContext {
	var p = new(ExprUseCloserContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseCloserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseCloserContext) USE() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE, 0)
}

func (s *ExprUseCloserContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseCloserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseCloser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAssignContext struct {
	*ExprContext
}

func NewExprAssignContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAssignContext {
	var p = new(ExprAssignContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAssignContext) AssignExpr() IAssignExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignExprContext)
}

func (s *ExprAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseMethodContext struct {
	*ExprContext
}

func NewExprUseMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseMethodContext {
	var p = new(ExprUseMethodContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseMethodContext) USE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE_AT, 0)
}

func (s *ExprUseMethodContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprUseMethodContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprWhenValueContext struct {
	*ExprContext
}

func NewExprWhenValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprWhenValueContext {
	var p = new(ExprWhenValueContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprWhenValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWhenValueContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ZggParserWHEN, 0)
}

func (s *ExprWhenValueContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprWhenValueContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWhenValueContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *ExprWhenValueContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *ExprWhenValueContext) AllWhenCondition() []IWhenConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem())
	var tst = make([]IWhenConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenConditionContext)
		}
	}

	return tst
}

func (s *ExprWhenValueContext) WhenCondition(i int) IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *ExprWhenValueContext) AllLEAD_TO() []antlr.TerminalNode {
	return s.GetTokens(ZggParserLEAD_TO)
}

func (s *ExprWhenValueContext) LEAD_TO(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserLEAD_TO, i)
}

func (s *ExprWhenValueContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, 0)
}

func (s *ExprWhenValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprWhenValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLiteralContext struct {
	*ExprContext
}

func NewExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLiteralContext {
	var p = new(ExprLiteralContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ExprLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprCompareContext struct {
	*ExprContext
}

func NewExprCompareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCompareContext {
	var p = new(ExprCompareContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCompareContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprCompareContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCompareContext) Comparator() IComparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparatorContext)
}

func (s *ExprCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprByFieldContext struct {
	*ExprContext
	field antlr.Token
}

func NewExprByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprByFieldContext {
	var p = new(ExprByFieldContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprByFieldContext) GetField() antlr.Token { return s.field }

func (s *ExprByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *ExprByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprByFieldContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *ExprByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprByField(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicOrContext struct {
	*ExprContext
}

func NewExprLogicOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicOrContext {
	var p = new(ExprLogicOrContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicOrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprLogicOrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicOrContext) LOGIC_OR() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_OR, 0)
}

func (s *ExprLogicOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitXorContext struct {
	*ExprContext
}

func NewExprBitXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitXorContext {
	var p = new(ExprBitXorContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitXorContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitXorContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitXorContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_XOR, 0)
}

func (s *ExprBitXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitXor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPreIncDecContext struct {
	*ExprContext
}

func NewExprPreIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPreIncDecContext {
	var p = new(ExprPreIncDecContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPreIncDecContext) PreIncDec() IPreIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncDecContext)
}

func (s *ExprPreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprUseBlockContext struct {
	*ExprContext
}

func NewExprUseBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUseBlockContext {
	var p = new(ExprUseBlockContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUseBlockContext) USE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserUSE_AT, 0)
}

func (s *ExprUseBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ExprUseBlockContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprUseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprUseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPowContext struct {
	*ExprContext
}

func NewExprPowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPowContext {
	var p = new(ExprPowContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPowContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprPowContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprPowContext) POW() antlr.TerminalNode {
	return s.GetToken(ZggParserPOW, 0)
}

func (s *ExprPowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPow(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprWhenContext struct {
	*ExprContext
}

func NewExprWhenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprWhenContext {
	var p = new(ExprWhenContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ZggParserWHEN, 0)
}

func (s *ExprWhenContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *ExprWhenContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *ExprWhenContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprWhenContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWhenContext) AllLEAD_TO() []antlr.TerminalNode {
	return s.GetTokens(ZggParserLEAD_TO)
}

func (s *ExprWhenContext) LEAD_TO(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserLEAD_TO, i)
}

func (s *ExprWhenContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserELSE, 0)
}

func (s *ExprWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitShiftContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprBitShiftContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitShiftContext {
	var p = new(ExprBitShiftContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitShiftContext) GetOp() antlr.Token { return s.op }

func (s *ExprBitShiftContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprBitShiftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitShiftContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitShiftContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitShiftContext) BIT_SHL() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHL, 0)
}

func (s *ExprBitShiftContext) BIT_SHR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHR, 0)
}

func (s *ExprBitShiftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitShift(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicNotContext struct {
	*ExprContext
}

func NewExprLogicNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicNotContext {
	var p = new(ExprLogicNotContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicNotContext) LOGIC_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_NOT, 0)
}

func (s *ExprLogicNotContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprLogicAndContext struct {
	*ExprContext
}

func NewExprLogicAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicAndContext {
	var p = new(ExprLogicAndContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicAndContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprLogicAndContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicAndContext) LOGIC_AND() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_AND, 0)
}

func (s *ExprLogicAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprLogicAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprIdentifierContext struct {
	*ExprContext
}

func NewExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIdentifierContext {
	var p = new(ExprIdentifierContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprFallbackContext struct {
	*ExprContext
}

func NewExprFallbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprFallbackContext {
	var p = new(ExprFallbackContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprFallbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprFallbackContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprFallbackContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprFallbackContext) OPTIONAL_ELSE() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_ELSE, 0)
}

func (s *ExprFallbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprFallback(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitAndContext struct {
	*ExprContext
}

func NewExprBitAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitAndContext {
	var p = new(ExprBitAndContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitAndContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitAndContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitAndContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_AND, 0)
}

func (s *ExprBitAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprNegativeContext struct {
	*ExprContext
}

func NewExprNegativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprNegativeContext {
	var p = new(ExprNegativeContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprNegativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprNegativeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS, 0)
}

func (s *ExprNegativeContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprNegativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprNegative(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprTimesDivModContext struct {
	*ExprContext
	op antlr.Token
}

func NewExprTimesDivModContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprTimesDivModContext {
	var p = new(ExprTimesDivModContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprTimesDivModContext) GetOp() antlr.Token { return s.op }

func (s *ExprTimesDivModContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprTimesDivModContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprTimesDivModContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprTimesDivModContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprTimesDivModContext) TIMES() antlr.TerminalNode {
	return s.GetToken(ZggParserTIMES, 0)
}

func (s *ExprTimesDivModContext) DIV() antlr.TerminalNode {
	return s.GetToken(ZggParserDIV, 0)
}

func (s *ExprTimesDivModContext) MOD() antlr.TerminalNode {
	return s.GetToken(ZggParserMOD, 0)
}

func (s *ExprTimesDivModContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprTimesDivMod(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprByIndexContext struct {
	*ExprContext
	index IExprContext
}

func NewExprByIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprByIndexContext {
	var p = new(ExprByIndexContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprByIndexContext) GetIndex() IExprContext { return s.index }

func (s *ExprByIndexContext) SetIndex(v IExprContext) { s.index = v }

func (s *ExprByIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprByIndexContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprByIndexContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprByIndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *ExprByIndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *ExprByIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprByIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitNotContext struct {
	*ExprContext
}

func NewExprBitNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitNotContext {
	var p = new(ExprBitNotContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitNotContext) BIT_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_NOT, 0)
}

func (s *ExprBitNotContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprShortImportContext struct {
	*ExprContext
}

func NewExprShortImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprShortImportContext {
	var p = new(ExprShortImportContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprShortImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprShortImportContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *ExprShortImportContext) SINGLE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserSINGLE_AT, 0)
}

func (s *ExprShortImportContext) DOUBLE_AT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOUBLE_AT, 0)
}

func (s *ExprShortImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprShortImport(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprSubContext struct {
	*ExprContext
}

func NewExprSubContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprSubContext {
	var p = new(ExprSubContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprSubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSubContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *ExprSubContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprSubContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *ExprSubContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprSub(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprCallContext struct {
	*ExprContext
}

func NewExprCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCallContext {
	var p = new(ExprCallContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCallContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCallContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ExprCallContext) OPTIONAL_CALL() antlr.TerminalNode {
	return s.GetToken(ZggParserOPTIONAL_CALL, 0)
}

func (s *ExprCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprBitOrContext struct {
	*ExprContext
}

func NewExprBitOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBitOrContext {
	var p = new(ExprBitOrContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBitOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBitOrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBitOrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBitOrContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_OR, 0)
}

func (s *ExprBitOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprBitOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAssertErrorContext struct {
	*ExprContext
}

func NewExprAssertErrorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAssertErrorContext {
	var p = new(ExprAssertErrorContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAssertErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAssertErrorContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAssertErrorContext) LOGIC_NOT() antlr.TerminalNode {
	return s.GetToken(ZggParserLOGIC_NOT, 0)
}

func (s *ExprAssertErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprAssertError(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprQuestionContext struct {
	*ExprContext
	condition IExprContext
	trueExpr  IExprContext
	falseExpr IExprContext
}

func NewExprQuestionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprQuestionContext {
	var p = new(ExprQuestionContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprQuestionContext) GetCondition() IExprContext { return s.condition }

func (s *ExprQuestionContext) GetTrueExpr() IExprContext { return s.trueExpr }

func (s *ExprQuestionContext) GetFalseExpr() IExprContext { return s.falseExpr }

func (s *ExprQuestionContext) SetCondition(v IExprContext) { s.condition = v }

func (s *ExprQuestionContext) SetTrueExpr(v IExprContext) { s.trueExpr = v }

func (s *ExprQuestionContext) SetFalseExpr(v IExprContext) { s.falseExpr = v }

func (s *ExprQuestionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprQuestionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ZggParserQUESTION, 0)
}

func (s *ExprQuestionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *ExprQuestionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprQuestionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprQuestionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprQuestion(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprPostIncDecContext struct {
	*ExprContext
}

func NewExprPostIncDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprPostIncDecContext {
	var p = new(ExprPostIncDecContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprPostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprPostIncDecContext) PostIncDec() IPostIncDecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncDecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostIncDecContext)
}

func (s *ExprPostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitExprPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *ZggParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 22
	p.EnterRecursionRule(localctx, 22, ZggParserRULE_expr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExprShortImportContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(330)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserSINGLE_AT || _la == ZggParserDOUBLE_AT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(331)
			p.Match(ZggParserIDENTIFIER)
		}

	case 2:
		localctx = NewExprPreIncDecContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(332)
			p.PreIncDec()
		}

	case 3:
		localctx = NewExprPostIncDecContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(333)
			p.PostIncDec()
		}

	case 4:
		localctx = NewExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(334)
			p.Match(ZggParserIDENTIFIER)
		}

	case 5:
		localctx = NewExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(335)
			p.Literal()
		}

	case 6:
		localctx = NewExprNegativeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(336)
			p.Match(ZggParserMINUS)
		}
		{
			p.SetState(337)
			p.expr(23)
		}

	case 7:
		localctx = NewExprLogicNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(338)
			p.Match(ZggParserLOGIC_NOT)
		}
		{
			p.SetState(339)
			p.expr(22)
		}

	case 8:
		localctx = NewExprBitNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(340)
			p.Match(ZggParserBIT_NOT)
		}
		{
			p.SetState(341)
			p.expr(21)
		}

	case 9:
		localctx = NewExprWhenContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(342)
			p.Match(ZggParserWHEN)
		}
		{
			p.SetState(343)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
			{
				p.SetState(344)
				p.expr(0)
			}
			{
				p.SetState(345)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(346)
				p.expr(0)
			}

			p.SetState(350)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(352)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(353)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(354)
				p.expr(0)
			}

		}
		{
			p.SetState(357)
			p.Match(ZggParserR_CURLY)
		}

	case 10:
		localctx = NewExprWhenValueContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(359)
			p.Match(ZggParserWHEN)
		}
		{
			p.SetState(360)
			p.expr(0)
		}
		{
			p.SetState(361)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(ZggParserRANGE_WITHOUT_END-77))|(1<<(ZggParserRANGE_WITH_END-77))|(1<<(ZggParserL_PAREN-77))|(1<<(ZggParserL_CURLY-77))|(1<<(ZggParserL_BRACKET-77))|(1<<(ZggParserLOGIC_NOT-77))|(1<<(ZggParserMINUS-77))|(1<<(ZggParserSINGLE_AT-77))|(1<<(ZggParserDOUBLE_AT-77))|(1<<(ZggParserQUOTE-77))|(1<<(ZggParserIDENTIFIER-77)))) != 0) {
			{
				p.SetState(362)
				p.WhenCondition()
			}
			{
				p.SetState(363)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(364)
				p.expr(0)
			}

			p.SetState(368)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserELSE {
			{
				p.SetState(370)
				p.Match(ZggParserELSE)
			}
			{
				p.SetState(371)
				p.Match(ZggParserLEAD_TO)
			}
			{
				p.SetState(372)
				p.expr(0)
			}

		}
		{
			p.SetState(375)
			p.Match(ZggParserR_CURLY)
		}

	case 11:
		localctx = NewExprAssignContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(377)
			p.AssignExpr()
		}

	case 12:
		localctx = NewExprSubContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(378)
			p.Match(ZggParserL_PAREN)
		}
		{
			p.SetState(379)
			p.expr(0)
		}
		{
			p.SetState(380)
			p.Match(ZggParserR_PAREN)
		}

	case 13:
		localctx = NewExprUseMethodContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(382)
			p.Match(ZggParserUSE_AT)
		}
		{
			p.SetState(383)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(384)
			p.expr(4)
		}

	case 14:
		localctx = NewExprUseBlockContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(385)
			p.Match(ZggParserUSE_AT)
		}
		{
			p.SetState(386)
			p.CodeBlock()
		}
		{
			p.SetState(387)
			p.expr(3)
		}

	case 15:
		localctx = NewExprUseCloserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(389)
			p.Match(ZggParserUSE)
		}
		{
			p.SetState(390)
			p.expr(2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(448)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprPowContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(393)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(394)
					p.Match(ZggParserPOW)
				}
				{
					p.SetState(395)
					p.expr(20)
				}

			case 2:
				localctx = NewExprTimesDivModContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(396)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(397)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprTimesDivModContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ZggParserTIMES-96))|(1<<(ZggParserDIV-96))|(1<<(ZggParserMOD-96)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprTimesDivModContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(398)
					p.expr(20)
				}

			case 3:
				localctx = NewExprPlusMinusContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(399)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(400)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprPlusMinusContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ZggParserPLUS || _la == ZggParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprPlusMinusContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(401)
					p.expr(19)
				}

			case 4:
				localctx = NewExprBitShiftContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(402)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(403)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprBitShiftContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ZggParserBIT_SHL || _la == ZggParserBIT_SHR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprBitShiftContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(404)
					p.expr(18)
				}

			case 5:
				localctx = NewExprCompareContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(405)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(406)
					p.Comparator()
				}
				{
					p.SetState(407)
					p.expr(17)
				}

			case 6:
				localctx = NewExprBitAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(409)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(410)
					p.Match(ZggParserBIT_AND)
				}
				{
					p.SetState(411)
					p.expr(16)
				}

			case 7:
				localctx = NewExprBitOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(412)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(413)
					p.Match(ZggParserBIT_OR)
				}
				{
					p.SetState(414)
					p.expr(15)
				}

			case 8:
				localctx = NewExprBitXorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(415)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(416)
					p.Match(ZggParserBIT_XOR)
				}
				{
					p.SetState(417)
					p.expr(14)
				}

			case 9:
				localctx = NewExprLogicAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(418)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(419)
					p.Match(ZggParserLOGIC_AND)
				}
				{
					p.SetState(420)
					p.expr(13)
				}

			case 10:
				localctx = NewExprLogicOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(421)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(422)
					p.Match(ZggParserLOGIC_OR)
				}
				{
					p.SetState(423)
					p.expr(12)
				}

			case 11:
				localctx = NewExprQuestionContext(p, NewExprContext(p, _parentctx, _parentState))
				localctx.(*ExprQuestionContext).condition = _prevctx

				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(424)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(425)
					p.Match(ZggParserQUESTION)
				}
				{
					p.SetState(426)

					var _x = p.expr(0)

					localctx.(*ExprQuestionContext).trueExpr = _x
				}
				{
					p.SetState(427)
					p.Match(ZggParserCOLON)
				}
				{
					p.SetState(428)

					var _x = p.expr(9)

					localctx.(*ExprQuestionContext).falseExpr = _x
				}

			case 12:
				localctx = NewExprFallbackContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(430)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(431)
					p.Match(ZggParserOPTIONAL_ELSE)
				}
				{
					p.SetState(432)
					p.expr(8)
				}

			case 13:
				localctx = NewExprCallContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(433)

				if !(p.Precpred(p.GetParserRuleContext(), 31)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 31)", ""))
				}
				p.SetState(435)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserOPTIONAL_CALL {
					{
						p.SetState(434)
						p.Match(ZggParserOPTIONAL_CALL)
					}

				}
				{
					p.SetState(437)
					p.Arguments()
				}

			case 14:
				localctx = NewExprByFieldContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(438)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
				}
				{
					p.SetState(439)
					p.Match(ZggParserDOT)
				}
				{
					p.SetState(440)

					var _m = p.Match(ZggParserIDENTIFIER)

					localctx.(*ExprByFieldContext).field = _m
				}

			case 15:
				localctx = NewExprByIndexContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(441)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(442)
					p.Match(ZggParserL_BRACKET)
				}
				{
					p.SetState(443)

					var _x = p.expr(0)

					localctx.(*ExprByIndexContext).index = _x
				}
				{
					p.SetState(444)
					p.Match(ZggParserR_BRACKET)
				}

			case 16:
				localctx = NewExprAssertErrorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_expr)
				p.SetState(446)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(447)
					p.Match(ZggParserLOGIC_NOT)
				}

			}

		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}

	return localctx
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_whenCondition
	return p
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) CopyFrom(ctx *WhenConditionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WhenConditionInRangeContext struct {
	*WhenConditionContext
	lowerBound IExprContext
	upperBound IExprContext
}

func NewWhenConditionInRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenConditionInRangeContext {
	var p = new(WhenConditionInRangeContext)

	p.WhenConditionContext = NewEmptyWhenConditionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WhenConditionContext))

	return p
}

func (s *WhenConditionInRangeContext) GetLowerBound() IExprContext { return s.lowerBound }

func (s *WhenConditionInRangeContext) GetUpperBound() IExprContext { return s.upperBound }

func (s *WhenConditionInRangeContext) SetLowerBound(v IExprContext) { s.lowerBound = v }

func (s *WhenConditionInRangeContext) SetUpperBound(v IExprContext) { s.upperBound = v }

func (s *WhenConditionInRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionInRangeContext) RANGE_WITH_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITH_END, 0)
}

func (s *WhenConditionInRangeContext) RANGE_WITHOUT_END() antlr.TerminalNode {
	return s.GetToken(ZggParserRANGE_WITHOUT_END, 0)
}

func (s *WhenConditionInRangeContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *WhenConditionInRangeContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenConditionInRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitWhenConditionInRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhenConditionInListContext struct {
	*WhenConditionContext
}

func NewWhenConditionInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenConditionInListContext {
	var p = new(WhenConditionInListContext)

	p.WhenConditionContext = NewEmptyWhenConditionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WhenConditionContext))

	return p
}

func (s *WhenConditionInListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionInListContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *WhenConditionInListContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenConditionInListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *WhenConditionInListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *WhenConditionInListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitWhenConditionInList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) WhenCondition() (localctx IWhenConditionContext) {
	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ZggParserRULE_whenCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWhenConditionInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(453)
			p.expr(0)
		}
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserCOMMA {
			{
				p.SetState(454)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(455)
				p.expr(0)
			}

			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewWhenConditionInRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
			{
				p.SetState(461)

				var _x = p.expr(0)

				localctx.(*WhenConditionInRangeContext).lowerBound = _x
			}

		}
		{
			p.SetState(464)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserRANGE_WITHOUT_END || _la == ZggParserRANGE_WITH_END) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
			{
				p.SetState(465)

				var _x = p.expr(0)

				localctx.(*WhenConditionInRangeContext).upperBound = _x
			}

		}

	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *ArgumentsContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *ArgumentsContext) AllFuncArgument() []IFuncArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFuncArgumentContext)(nil)).Elem())
	var tst = make([]IFuncArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFuncArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentsContext) FuncArgument(i int) IFuncArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFuncArgumentContext)
}

func (s *ArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *ArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ZggParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(ZggParserL_PAREN)
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
		{
			p.SetState(471)
			p.FuncArgument()
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(472)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(473)
					p.FuncArgument()
				}

			}
			p.SetState(478)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(479)
				p.Match(ZggParserCOMMA)
			}

		}

	}
	{
		p.SetState(484)
		p.Match(ZggParserR_PAREN)
	}

	return localctx
}

// IFuncArgumentContext is an interface to support dynamic dispatch.
type IFuncArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncArgumentContext differentiates from other interfaces.
	IsFuncArgumentContext()
}

type FuncArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncArgumentContext() *FuncArgumentContext {
	var p = new(FuncArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_funcArgument
	return p
}

func (*FuncArgumentContext) IsFuncArgumentContext() {}

func NewFuncArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncArgumentContext {
	var p = new(FuncArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_funcArgument

	return p
}

func (s *FuncArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncArgumentContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FuncArgumentContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FuncArgumentContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *FuncArgumentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *FuncArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *FuncArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitFuncArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) FuncArgument() (localctx IFuncArgumentContext) {
	localctx = NewFuncArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ZggParserRULE_funcArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
		case 1:
			p.SetState(487)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(486)
					p.Match(ZggParserMORE_ARGS)
				}

			}
			{
				p.SetState(489)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(490)
				p.CodeBlock()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(493)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(494)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(495)
			p.expr(0)
		}

	}

	return localctx
}

// IAssignExprContext is an interface to support dynamic dispatch.
type IAssignExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignExprContext differentiates from other interfaces.
	IsAssignExprContext()
}

type AssignExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignExprContext() *AssignExprContext {
	var p = new(AssignExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_assignExpr
	return p
}

func (*AssignExprContext) IsAssignExprContext() {}

func NewAssignExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignExprContext {
	var p = new(AssignExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_assignExpr

	return p
}

func (s *AssignExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignExprContext) CopyFrom(ctx *AssignExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AssignExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssignNewLocalContext struct {
	*AssignExprContext
}

func NewAssignNewLocalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewLocalContext {
	var p = new(AssignNewLocalContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewLocalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewLocalContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *AssignNewLocalContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewLocalContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewLocalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewLocal(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignExistsContext struct {
	*AssignExprContext
	op antlr.Token
}

func NewAssignExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignExistsContext {
	var p = new(AssignExistsContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignExistsContext) GetOp() antlr.Token { return s.op }

func (s *AssignExistsContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExistsContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *AssignExistsContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignExistsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserASSIGN, 0)
}

func (s *AssignExistsContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_ASSIGN, 0)
}

func (s *AssignExistsContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_ASSIGN, 0)
}

func (s *AssignExistsContext) TIMES_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserTIMES_ASSIGN, 0)
}

func (s *AssignExistsContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserDIV_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_AND_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_OR_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_XOR_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_SHL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHL_ASSIGN, 0)
}

func (s *AssignExistsContext) BIT_SHR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserBIT_SHR_ASSIGN, 0)
}

func (s *AssignExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewDeObjectContext struct {
	*AssignExprContext
}

func NewAssignNewDeObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewDeObjectContext {
	var p = new(AssignNewDeObjectContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewDeObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewDeObjectContext) AllL_CURLY() []antlr.TerminalNode {
	return s.GetTokens(ZggParserL_CURLY)
}

func (s *AssignNewDeObjectContext) L_CURLY(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, i)
}

func (s *AssignNewDeObjectContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *AssignNewDeObjectContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *AssignNewDeObjectContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewDeObjectContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewDeObjectContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *AssignNewDeObjectContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *AssignNewDeObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewDeObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewContext struct {
	*AssignExprContext
}

func NewAssignNewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewContext {
	var p = new(AssignNewContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *AssignNewContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNew(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignNewDeArrayContext struct {
	*AssignExprContext
}

func NewAssignNewDeArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignNewDeArrayContext {
	var p = new(AssignNewDeArrayContext)

	p.AssignExprContext = NewEmptyAssignExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssignExprContext))

	return p
}

func (s *AssignNewDeArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignNewDeArrayContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *AssignNewDeArrayContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *AssignNewDeArrayContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *AssignNewDeArrayContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *AssignNewDeArrayContext) LOCAL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ZggParserLOCAL_ASSIGN, 0)
}

func (s *AssignNewDeArrayContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignNewDeArrayContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *AssignNewDeArrayContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *AssignNewDeArrayContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *AssignNewDeArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitAssignNewDeArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) AssignExpr() (localctx IAssignExprContext) {
	localctx = NewAssignExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ZggParserRULE_assignExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssignExistsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(498)
			p.lval(0)
		}
		{
			p.SetState(499)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignExistsContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ZggParserPLUS_ASSIGN-57))|(1<<(ZggParserMINUS_ASSIGN-57))|(1<<(ZggParserTIMES_ASSIGN-57))|(1<<(ZggParserDIV_ASSIGN-57))|(1<<(ZggParserBIT_AND_ASSIGN-57))|(1<<(ZggParserBIT_OR_ASSIGN-57))|(1<<(ZggParserBIT_SHL_ASSIGN-57))|(1<<(ZggParserBIT_SHR_ASSIGN-57))|(1<<(ZggParserBIT_XOR_ASSIGN-57)))) != 0) || _la == ZggParserASSIGN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignExistsContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(500)
			p.expr(0)
		}

	case 2:
		localctx = NewAssignNewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(503)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(504)
			p.expr(0)
		}

	case 3:
		localctx = NewAssignNewDeArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(505)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(506)
			p.Match(ZggParserIDENTIFIER)
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(507)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(508)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(513)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(514)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(515)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(516)
				p.Match(ZggParserIDENTIFIER)
			}

		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserCOMMA {
			{
				p.SetState(519)
				p.Match(ZggParserCOMMA)
			}

		}
		{
			p.SetState(522)
			p.Match(ZggParserR_BRACKET)
		}
		{
			p.SetState(523)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(524)
			p.expr(0)
		}

	case 4:
		localctx = NewAssignNewDeObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(525)
			p.Match(ZggParserL_CURLY)
		}
		{
			p.SetState(526)
			p.Match(ZggParserIDENTIFIER)
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ZggParserCOMMA {
			{
				p.SetState(527)
				p.Match(ZggParserCOMMA)
			}
			{
				p.SetState(528)
				p.Match(ZggParserIDENTIFIER)
			}

			p.SetState(533)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(534)
			p.Match(ZggParserL_CURLY)
		}
		{
			p.SetState(535)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(536)
			p.expr(0)
		}

	case 5:
		localctx = NewAssignNewLocalContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(537)
			p.Match(ZggParserMORE_ARGS)
		}
		{
			p.SetState(538)
			p.Match(ZggParserLOCAL_ASSIGN)
		}
		{
			p.SetState(539)
			p.expr(0)
		}

	}

	return localctx
}

// IPreIncDecContext is an interface to support dynamic dispatch.
type IPreIncDecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPreIncDecContext differentiates from other interfaces.
	IsPreIncDecContext()
}

type PreIncDecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPreIncDecContext() *PreIncDecContext {
	var p = new(PreIncDecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_preIncDec
	return p
}

func (*PreIncDecContext) IsPreIncDecContext() {}

func NewPreIncDecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreIncDecContext {
	var p = new(PreIncDecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_preIncDec

	return p
}

func (s *PreIncDecContext) GetParser() antlr.Parser { return s.parser }

func (s *PreIncDecContext) GetOp() antlr.Token { return s.op }

func (s *PreIncDecContext) SetOp(v antlr.Token) { s.op = v }

func (s *PreIncDecContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *PreIncDecContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_PLUS, 0)
}

func (s *PreIncDecContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_MINUS, 0)
}

func (s *PreIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncDecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitPreIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) PreIncDec() (localctx IPreIncDecContext) {
	localctx = NewPreIncDecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ZggParserRULE_preIncDec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PreIncDecContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ZggParserPLUS_PLUS || _la == ZggParserMINUS_MINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PreIncDecContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(543)
		p.lval(0)
	}

	return localctx
}

// IPostIncDecContext is an interface to support dynamic dispatch.
type IPostIncDecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPostIncDecContext differentiates from other interfaces.
	IsPostIncDecContext()
}

type PostIncDecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPostIncDecContext() *PostIncDecContext {
	var p = new(PostIncDecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_postIncDec
	return p
}

func (*PostIncDecContext) IsPostIncDecContext() {}

func NewPostIncDecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncDecContext {
	var p = new(PostIncDecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_postIncDec

	return p
}

func (s *PostIncDecContext) GetParser() antlr.Parser { return s.parser }

func (s *PostIncDecContext) GetOp() antlr.Token { return s.op }

func (s *PostIncDecContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostIncDecContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *PostIncDecContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(ZggParserPLUS_PLUS, 0)
}

func (s *PostIncDecContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(ZggParserMINUS_MINUS, 0)
}

func (s *PostIncDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncDecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitPostIncDec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) PostIncDec() (localctx IPostIncDecContext) {
	localctx = NewPostIncDecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ZggParserRULE_postIncDec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.lval(0)
	}
	{
		p.SetState(546)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PostIncDecContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ZggParserPLUS_PLUS || _la == ZggParserMINUS_MINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PostIncDecContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILvalContext is an interface to support dynamic dispatch.
type ILvalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLvalContext differentiates from other interfaces.
	IsLvalContext()
}

type LvalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLvalContext() *LvalContext {
	var p = new(LvalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_lval
	return p
}

func (*LvalContext) IsLvalContext() {}

func NewLvalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LvalContext {
	var p = new(LvalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_lval

	return p
}

func (s *LvalContext) GetParser() antlr.Parser { return s.parser }

func (s *LvalContext) CopyFrom(ctx *LvalContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LvalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LvalByIdContext struct {
	*LvalContext
}

func NewLvalByIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByIdContext {
	var p = new(LvalByIdContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByIdContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *LvalByIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalById(s)

	default:
		return t.VisitChildren(s)
	}
}

type LvalByIndexContext struct {
	*LvalContext
	index IExprContext
}

func NewLvalByIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByIndexContext {
	var p = new(LvalByIndexContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByIndexContext) GetIndex() IExprContext { return s.index }

func (s *LvalByIndexContext) SetIndex(v IExprContext) { s.index = v }

func (s *LvalByIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByIndexContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *LvalByIndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *LvalByIndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *LvalByIndexContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LvalByIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalByIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type LvalByFieldContext struct {
	*LvalContext
	field antlr.Token
}

func NewLvalByFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LvalByFieldContext {
	var p = new(LvalByFieldContext)

	p.LvalContext = NewEmptyLvalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LvalContext))

	return p
}

func (s *LvalByFieldContext) GetField() antlr.Token { return s.field }

func (s *LvalByFieldContext) SetField(v antlr.Token) { s.field = v }

func (s *LvalByFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalByFieldContext) Lval() ILvalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalContext)
}

func (s *LvalByFieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ZggParserDOT, 0)
}

func (s *LvalByFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *LvalByFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLvalByField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Lval() (localctx ILvalContext) {
	return p.lval(0)
}

func (p *ZggParser) lval(_p int) (localctx ILvalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLvalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILvalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, ZggParserRULE_lval, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewLvalByIdContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(549)
		p.Match(ZggParserIDENTIFIER)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(559)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLvalByFieldContext(p, NewLvalContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_lval)
				p.SetState(551)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(552)
					p.Match(ZggParserDOT)
				}
				{
					p.SetState(553)

					var _m = p.Match(ZggParserIDENTIFIER)

					localctx.(*LvalByFieldContext).field = _m
				}

			case 2:
				localctx = NewLvalByIndexContext(p, NewLvalContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ZggParserRULE_lval)
				p.SetState(554)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(555)
					p.Match(ZggParserL_BRACKET)
				}
				{
					p.SetState(556)

					var _x = p.expr(0)

					localctx.(*LvalByIndexContext).index = _x
				}
				{
					p.SetState(557)
					p.Match(ZggParserR_BRACKET)
				}

			}

		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_integer
	return p
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) CopyFrom(ctx *IntegerContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IntegerHexContext struct {
	*IntegerContext
}

func NewIntegerHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerHexContext {
	var p = new(IntegerHexContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerHexContext) INT_HEX() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_HEX, 0)
}

func (s *IntegerHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerBinContext struct {
	*IntegerContext
}

func NewIntegerBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerBinContext {
	var p = new(IntegerBinContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerBinContext) INT_BIN() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_BIN, 0)
}

func (s *IntegerBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerBin(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerDecContext struct {
	*IntegerContext
}

func NewIntegerDecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerDecContext {
	var p = new(IntegerDecContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerDecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerDecContext) INT_DEC() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_DEC, 0)
}

func (s *IntegerDecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerDec(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerZeroContext struct {
	*IntegerContext
}

func NewIntegerZeroContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerZeroContext {
	var p = new(IntegerZeroContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerZeroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerZeroContext) INT_ZERO() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_ZERO, 0)
}

func (s *IntegerZeroContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerZero(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerOctContext struct {
	*IntegerContext
}

func NewIntegerOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerOctContext {
	var p = new(IntegerOctContext)

	p.IntegerContext = NewEmptyIntegerContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntegerContext))

	return p
}

func (s *IntegerOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerOctContext) INT_OCT() antlr.TerminalNode {
	return s.GetToken(ZggParserINT_OCT, 0)
}

func (s *IntegerOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitIntegerOct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ZggParserRULE_integer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(569)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserINT_ZERO:
		localctx = NewIntegerZeroContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(564)
			p.Match(ZggParserINT_ZERO)
		}

	case ZggParserINT_DEC:
		localctx = NewIntegerDecContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(565)
			p.Match(ZggParserINT_DEC)
		}

	case ZggParserINT_HEX:
		localctx = NewIntegerHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(566)
			p.Match(ZggParserINT_HEX)
		}

	case ZggParserINT_OCT:
		localctx = NewIntegerOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(567)
			p.Match(ZggParserINT_OCT)
		}

	case ZggParserINT_BIN:
		localctx = NewIntegerBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(568)
			p.Match(ZggParserINT_BIN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LiteralIntegerContext struct {
	*LiteralContext
}

func NewLiteralIntegerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralIntegerContext {
	var p = new(LiteralIntegerContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralIntegerContext) Integer() IIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *LiteralIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralFloatContext struct {
	*LiteralContext
}

func NewLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralFloatContext {
	var p = new(LiteralFloatContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ZggParserFLOAT, 0)
}

func (s *LiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralObjectContext struct {
	*LiteralContext
}

func NewLiteralObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralObjectContext {
	var p = new(LiteralObjectContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralObjectContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserL_CURLY, 0)
}

func (s *LiteralObjectContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *LiteralObjectContext) AllObjItem() []IObjItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjItemContext)(nil)).Elem())
	var tst = make([]IObjItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjItemContext)
		}
	}

	return tst
}

func (s *LiteralObjectContext) ObjItem(i int) IObjItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjItemContext)
}

func (s *LiteralObjectContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralObjectContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralBoolContext struct {
	*LiteralContext
}

func NewLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralBoolContext {
	var p = new(LiteralBoolContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralBoolContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ZggParserTRUE, 0)
}

func (s *LiteralBoolContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ZggParserFALSE, 0)
}

func (s *LiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralArrayContext struct {
	*LiteralContext
}

func NewLiteralArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralArrayContext {
	var p = new(LiteralArrayContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralArrayContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *LiteralArrayContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *LiteralArrayContext) AllArrayItem() []IArrayItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayItemContext)(nil)).Elem())
	var tst = make([]IArrayItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayItemContext)
		}
	}

	return tst
}

func (s *LiteralArrayContext) ArrayItem(i int) IArrayItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *LiteralArrayContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralArrayContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralBigNumContext struct {
	*LiteralContext
}

func NewLiteralBigNumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralBigNumContext {
	var p = new(LiteralBigNumContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralBigNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralBigNumContext) BIGNUM() antlr.TerminalNode {
	return s.GetToken(ZggParserBIGNUM, 0)
}

func (s *LiteralBigNumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralBigNum(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralStringContext struct {
	*LiteralContext
}

func NewLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralStringContext {
	var p = new(LiteralStringContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralStringContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralLambdaExprContext struct {
	*LiteralContext
}

func NewLiteralLambdaExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralLambdaExprContext {
	var p = new(LiteralLambdaExprContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralLambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralLambdaExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ZggParserARROW, 0)
}

func (s *LiteralLambdaExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LiteralLambdaExprContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralLambdaExprContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralLambdaExprContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralLambdaExprContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralLambdaExprContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralLambdaExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralLambdaExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralLambdaExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralLambdaExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralNilContext struct {
	*LiteralContext
}

func NewLiteralNilContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralNilContext {
	var p = new(LiteralNilContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralNilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralNilContext) NIL() antlr.TerminalNode {
	return s.GetToken(ZggParserNIL, 0)
}

func (s *LiteralNilContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralNil(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralUndefinedContext struct {
	*LiteralContext
}

func NewLiteralUndefinedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralUndefinedContext {
	var p = new(LiteralUndefinedContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralUndefinedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralUndefinedContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ZggParserUNDEFINED, 0)
}

func (s *LiteralUndefinedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralUndefined(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralFuncContext struct {
	*LiteralContext
}

func NewLiteralFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralFuncContext {
	var p = new(LiteralFuncContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralFuncContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ZggParserFUNC, 0)
}

func (s *LiteralFuncContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralFuncContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralFuncContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LiteralFuncContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralFuncContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralFuncContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralFuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralFuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralLambdaBlockContext struct {
	*LiteralContext
}

func NewLiteralLambdaBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralLambdaBlockContext {
	var p = new(LiteralLambdaBlockContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *LiteralLambdaBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralLambdaBlockContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ZggParserARROW, 0)
}

func (s *LiteralLambdaBlockContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LiteralLambdaBlockContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *LiteralLambdaBlockContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *LiteralLambdaBlockContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *LiteralLambdaBlockContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *LiteralLambdaBlockContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *LiteralLambdaBlockContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *LiteralLambdaBlockContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *LiteralLambdaBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitLiteralLambdaBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ZggParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralIntegerContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(571)
			p.Integer()
		}

	case 2:
		localctx = NewLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.Match(ZggParserFLOAT)
		}

	case 3:
		localctx = NewLiteralBigNumContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(573)
			p.Match(ZggParserBIGNUM)
		}

	case 4:
		localctx = NewLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(574)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ZggParserTRUE || _la == ZggParserFALSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		localctx = NewLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(575)
			p.StringLiteral()
		}

	case 6:
		localctx = NewLiteralNilContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(576)
			p.Match(ZggParserNIL)
		}

	case 7:
		localctx = NewLiteralUndefinedContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(577)
			p.Match(ZggParserUNDEFINED)
		}

	case 8:
		localctx = NewLiteralFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(578)
			p.Match(ZggParserFUNC)
		}
		{
			p.SetState(579)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(598)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(580)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(585)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(581)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(582)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(587)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
			}
			p.SetState(591)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(588)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(589)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(590)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(594)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(593)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(596)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(597)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(600)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(601)
			p.CodeBlock()
		}

	case 9:
		localctx = NewLiteralLambdaExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(625)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserL_PAREN:
			{
				p.SetState(602)
				p.Match(ZggParserL_PAREN)
			}
			p.SetState(621)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ZggParserIDENTIFIER:
				{
					p.SetState(603)
					p.Match(ZggParserIDENTIFIER)
				}
				p.SetState(608)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(604)
							p.Match(ZggParserCOMMA)
						}
						{
							p.SetState(605)
							p.Match(ZggParserIDENTIFIER)
						}

					}
					p.SetState(610)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
				}
				p.SetState(614)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(611)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(612)
						p.Match(ZggParserMORE_ARGS)
					}
					{
						p.SetState(613)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(617)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserCOMMA {
					{
						p.SetState(616)
						p.Match(ZggParserCOMMA)
					}

				}

			case ZggParserMORE_ARGS:
				{
					p.SetState(619)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(620)
					p.Match(ZggParserIDENTIFIER)
				}

			case ZggParserR_PAREN:

			default:
			}
			{
				p.SetState(623)
				p.Match(ZggParserR_PAREN)
			}

		case ZggParserIDENTIFIER:
			{
				p.SetState(624)
				p.Match(ZggParserIDENTIFIER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(627)
			p.Match(ZggParserARROW)
		}
		{
			p.SetState(628)
			p.expr(0)
		}

	case 10:
		localctx = NewLiteralLambdaBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(652)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserL_PAREN:
			{
				p.SetState(629)
				p.Match(ZggParserL_PAREN)
			}
			p.SetState(648)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ZggParserIDENTIFIER:
				{
					p.SetState(630)
					p.Match(ZggParserIDENTIFIER)
				}
				p.SetState(635)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(631)
							p.Match(ZggParserCOMMA)
						}
						{
							p.SetState(632)
							p.Match(ZggParserIDENTIFIER)
						}

					}
					p.SetState(637)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
				}
				p.SetState(641)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(638)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(639)
						p.Match(ZggParserMORE_ARGS)
					}
					{
						p.SetState(640)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(644)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ZggParserCOMMA {
					{
						p.SetState(643)
						p.Match(ZggParserCOMMA)
					}

				}

			case ZggParserMORE_ARGS:
				{
					p.SetState(646)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(647)
					p.Match(ZggParserIDENTIFIER)
				}

			case ZggParserR_PAREN:

			default:
			}
			{
				p.SetState(650)
				p.Match(ZggParserR_PAREN)
			}

		case ZggParserIDENTIFIER:
			{
				p.SetState(651)
				p.Match(ZggParserIDENTIFIER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(654)
			p.Match(ZggParserARROW)
		}
		{
			p.SetState(655)
			p.CodeBlock()
		}

	case 11:
		localctx = NewLiteralObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(656)
			p.Match(ZggParserL_CURLY)
		}
		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ZggParserSTRING || _la == ZggParserMORE_ARGS || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(ZggParserL_BRACKET-87))|(1<<(ZggParserQUOTE-87))|(1<<(ZggParserIDENTIFIER-87)))) != 0) {
			{
				p.SetState(657)
				p.ObjItem()
			}
			p.SetState(662)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(658)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(659)
						p.ObjItem()
					}

				}
				p.SetState(664)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
			}
			p.SetState(666)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(665)
					p.Match(ZggParserCOMMA)
				}

			}

		}
		{
			p.SetState(670)
			p.Match(ZggParserR_CURLY)
		}

	case 12:
		localctx = NewLiteralArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(671)
			p.Match(ZggParserL_BRACKET)
		}
		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ZggParserTRUE)|(1<<ZggParserFALSE)|(1<<ZggParserFUNC)|(1<<ZggParserWHEN)|(1<<ZggParserNIL)|(1<<ZggParserUNDEFINED)|(1<<ZggParserUSE_AT)|(1<<ZggParserUSE))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ZggParserINT_ZERO-38))|(1<<(ZggParserINT_DEC-38))|(1<<(ZggParserINT_HEX-38))|(1<<(ZggParserINT_OCT-38))|(1<<(ZggParserINT_BIN-38))|(1<<(ZggParserBIGNUM-38))|(1<<(ZggParserFLOAT-38))|(1<<(ZggParserSTRING-38))|(1<<(ZggParserMORE_ARGS-38))|(1<<(ZggParserPLUS_PLUS-38))|(1<<(ZggParserMINUS_MINUS-38))|(1<<(ZggParserBIT_NOT-38)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(ZggParserL_PAREN-83))|(1<<(ZggParserL_CURLY-83))|(1<<(ZggParserL_BRACKET-83))|(1<<(ZggParserLOGIC_NOT-83))|(1<<(ZggParserMINUS-83))|(1<<(ZggParserSINGLE_AT-83))|(1<<(ZggParserDOUBLE_AT-83))|(1<<(ZggParserQUOTE-83))|(1<<(ZggParserIDENTIFIER-83)))) != 0) {
			{
				p.SetState(672)
				p.ArrayItem()
			}
			p.SetState(677)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(673)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(674)
						p.ArrayItem()
					}

				}
				p.SetState(679)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
			}
			p.SetState(681)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(680)
					p.Match(ZggParserCOMMA)
				}

			}

		}
		{
			p.SetState(685)
			p.Match(ZggParserR_BRACKET)
		}

	}

	return localctx
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemContext differentiates from other interfaces.
	IsArrayItemContext()
}

type ArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemContext() *ArrayItemContext {
	var p = new(ArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_arrayItem
	return p
}

func (*ArrayItemContext) IsArrayItemContext() {}

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext {
	var p = new(ArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_arrayItem

	return p
}

func (s *ArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayItemContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitArrayItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ArrayItem() (localctx IArrayItemContext) {
	localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ZggParserRULE_arrayItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(689)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(688)
			p.Match(ZggParserMORE_ARGS)
		}

	}
	{
		p.SetState(691)
		p.expr(0)
	}

	return localctx
}

// IObjItemContext is an interface to support dynamic dispatch.
type IObjItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjItemContext differentiates from other interfaces.
	IsObjItemContext()
}

type ObjItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjItemContext() *ObjItemContext {
	var p = new(ObjItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_objItem
	return p
}

func (*ObjItemContext) IsObjItemContext() {}

func NewObjItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjItemContext {
	var p = new(ObjItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_objItem

	return p
}

func (s *ObjItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjItemContext) CopyFrom(ctx *ObjItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ObjItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ObjItemExpandedContext struct {
	*ObjItemContext
}

func NewObjItemExpandedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjItemExpandedContext {
	var p = new(ObjItemExpandedContext)

	p.ObjItemContext = NewEmptyObjItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ObjItemContext))

	return p
}

func (s *ObjItemExpandedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemExpandedContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *ObjItemExpandedContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjItemExpandedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitObjItemExpanded(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjItemKVContext struct {
	*ObjItemContext
}

func NewObjItemKVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjItemKVContext {
	var p = new(ObjItemKVContext)

	p.ObjItemContext = NewEmptyObjItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ObjItemContext))

	return p
}

func (s *ObjItemKVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjItemKVContext) KeyValue() IKeyValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyValueContext)
}

func (s *ObjItemKVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitObjItemKV(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) ObjItem() (localctx IObjItemContext) {
	localctx = NewObjItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ZggParserRULE_objItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserSTRING, ZggParserL_BRACKET, ZggParserQUOTE, ZggParserIDENTIFIER:
		localctx = NewObjItemKVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)
			p.KeyValue()
		}

	case ZggParserMORE_ARGS:
		localctx = NewObjItemExpandedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.Match(ZggParserMORE_ARGS)
		}
		{
			p.SetState(695)
			p.expr(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyValueContext is an interface to support dynamic dispatch.
type IKeyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyValueContext differentiates from other interfaces.
	IsKeyValueContext()
}

type KeyValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyValueContext() *KeyValueContext {
	var p = new(KeyValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_keyValue
	return p
}

func (*KeyValueContext) IsKeyValueContext() {}

func NewKeyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyValueContext {
	var p = new(KeyValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_keyValue

	return p
}

func (s *KeyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyValueContext) CopyFrom(ctx *KeyValueContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *KeyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KVStrKeyContext struct {
	*KeyValueContext
}

func NewKVStrKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVStrKeyContext {
	var p = new(KVStrKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVStrKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVStrKeyContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *KVStrKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVStrKeyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVStrKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVStrKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVKeyFuncContext struct {
	*KeyValueContext
}

func NewKVKeyFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVKeyFuncContext {
	var p = new(KVKeyFuncContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVKeyFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVKeyFuncContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ZggParserIDENTIFIER)
}

func (s *KVKeyFuncContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, i)
}

func (s *KVKeyFuncContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserL_PAREN, 0)
}

func (s *KVKeyFuncContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ZggParserR_PAREN, 0)
}

func (s *KVKeyFuncContext) CodeBlock() ICodeBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *KVKeyFuncContext) MORE_ARGS() antlr.TerminalNode {
	return s.GetToken(ZggParserMORE_ARGS, 0)
}

func (s *KVKeyFuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ZggParserCOMMA)
}

func (s *KVKeyFuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserCOMMA, i)
}

func (s *KVKeyFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVKeyFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVExprOnlyContext struct {
	*KeyValueContext
}

func NewKVExprOnlyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVExprOnlyContext {
	var p = new(KVExprOnlyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVExprOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVExprOnlyContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *KVExprOnlyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVExprOnlyContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *KVExprOnlyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVExprOnly(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVIdOnlyContext struct {
	*KeyValueContext
}

func NewKVIdOnlyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVIdOnlyContext {
	var p = new(KVIdOnlyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVIdOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVIdOnlyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *KVIdOnlyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVIdOnly(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVExprKeyContext struct {
	*KeyValueContext
}

func NewKVExprKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVExprKeyContext {
	var p = new(KVExprKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVExprKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVExprKeyContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserL_BRACKET, 0)
}

func (s *KVExprKeyContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *KVExprKeyContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVExprKeyContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ZggParserR_BRACKET, 0)
}

func (s *KVExprKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVExprKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVExprKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type KVIdKeyContext struct {
	*KeyValueContext
}

func NewKVIdKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KVIdKeyContext {
	var p = new(KVIdKeyContext)

	p.KeyValueContext = NewEmptyKeyValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*KeyValueContext))

	return p
}

func (s *KVIdKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KVIdKeyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserIDENTIFIER, 0)
}

func (s *KVIdKeyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ZggParserCOLON, 0)
}

func (s *KVIdKeyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KVIdKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitKVIdKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) KeyValue() (localctx IKeyValueContext) {
	localctx = NewKeyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ZggParserRULE_keyValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKVIdKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(699)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(700)
			p.expr(0)
		}

	case 2:
		localctx = NewKVStrKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(701)
			p.StringLiteral()
		}
		{
			p.SetState(702)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(703)
			p.expr(0)
		}

	case 3:
		localctx = NewKVExprKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(705)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(706)
			p.expr(0)
		}
		{
			p.SetState(707)
			p.Match(ZggParserR_BRACKET)
		}
		{
			p.SetState(708)
			p.Match(ZggParserCOLON)
		}
		{
			p.SetState(709)
			p.expr(0)
		}

	case 4:
		localctx = NewKVKeyFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(711)
			p.Match(ZggParserIDENTIFIER)
		}
		{
			p.SetState(712)
			p.Match(ZggParserL_PAREN)
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ZggParserIDENTIFIER:
			{
				p.SetState(713)
				p.Match(ZggParserIDENTIFIER)
			}
			p.SetState(718)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(714)
						p.Match(ZggParserCOMMA)
					}
					{
						p.SetState(715)
						p.Match(ZggParserIDENTIFIER)
					}

				}
				p.SetState(720)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
			}
			p.SetState(724)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(721)
					p.Match(ZggParserCOMMA)
				}
				{
					p.SetState(722)
					p.Match(ZggParserMORE_ARGS)
				}
				{
					p.SetState(723)
					p.Match(ZggParserIDENTIFIER)
				}

			}
			p.SetState(727)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ZggParserCOMMA {
				{
					p.SetState(726)
					p.Match(ZggParserCOMMA)
				}

			}

		case ZggParserMORE_ARGS:
			{
				p.SetState(729)
				p.Match(ZggParserMORE_ARGS)
			}
			{
				p.SetState(730)
				p.Match(ZggParserIDENTIFIER)
			}

		case ZggParserR_PAREN:

		default:
		}
		{
			p.SetState(733)
			p.Match(ZggParserR_PAREN)
		}
		{
			p.SetState(734)
			p.CodeBlock()
		}

	case 5:
		localctx = NewKVIdOnlyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(735)
			p.Match(ZggParserIDENTIFIER)
		}

	case 6:
		localctx = NewKVExprOnlyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(736)
			p.Match(ZggParserL_BRACKET)
		}
		{
			p.SetState(737)
			p.expr(0)
		}
		{
			p.SetState(738)
			p.Match(ZggParserR_BRACKET)
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(ZggParserSTRING, 0)
}

func (s *StringLiteralContext) TemplateString() ITemplateStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ZggParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			p.Match(ZggParserSTRING)
		}

	case ZggParserQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(743)
			p.TemplateString()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITemplateStringContext is an interface to support dynamic dispatch.
type ITemplateStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateStringContext differentiates from other interfaces.
	IsTemplateStringContext()
}

type TemplateStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringContext() *TemplateStringContext {
	var p = new(TemplateStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_templateString
	return p
}

func (*TemplateStringContext) IsTemplateStringContext() {}

func NewTemplateStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringContext {
	var p = new(TemplateStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_templateString

	return p
}

func (s *TemplateStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringContext) AllQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ZggParserQUOTE)
}

func (s *TemplateStringContext) QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ZggParserQUOTE, i)
}

func (s *TemplateStringContext) AllTsItem() []ITsItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITsItemContext)(nil)).Elem())
	var tst = make([]ITsItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITsItemContext)
		}
	}

	return tst
}

func (s *TemplateStringContext) TsItem(i int) ITsItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITsItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITsItemContext)
}

func (s *TemplateStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTemplateString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) TemplateString() (localctx ITemplateStringContext) {
	localctx = NewTemplateStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ZggParserRULE_templateString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ZggParserQUOTE)
	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(ZggParserTS_RAW-103))|(1<<(ZggParserTS_EXPR_START-103))|(1<<(ZggParserTS_IDENTIFIER-103)))) != 0 {
		{
			p.SetState(747)
			p.TsItem()
		}

		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(753)
		p.Match(ZggParserQUOTE)
	}

	return localctx
}

// ITsItemContext is an interface to support dynamic dispatch.
type ITsItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTsItemContext differentiates from other interfaces.
	IsTsItemContext()
}

type TsItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsItemContext() *TsItemContext {
	var p = new(TsItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ZggParserRULE_tsItem
	return p
}

func (*TsItemContext) IsTsItemContext() {}

func NewTsItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsItemContext {
	var p = new(TsItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ZggParserRULE_tsItem

	return p
}

func (s *TsItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TsItemContext) CopyFrom(ctx *TsItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TsItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TsRawContext struct {
	*TsItemContext
}

func NewTsRawContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsRawContext {
	var p = new(TsRawContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsRawContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsRawContext) TS_RAW() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_RAW, 0)
}

func (s *TsRawContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsRaw(s)

	default:
		return t.VisitChildren(s)
	}
}

type TsExprContext struct {
	*TsItemContext
}

func NewTsExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsExprContext {
	var p = new(TsExprContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsExprContext) TS_EXPR_START() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_EXPR_START, 0)
}

func (s *TsExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TsExprContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ZggParserR_CURLY, 0)
}

func (s *TsExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type TsIdentifierContext struct {
	*TsItemContext
}

func NewTsIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TsIdentifierContext {
	var p = new(TsIdentifierContext)

	p.TsItemContext = NewEmptyTsItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TsItemContext))

	return p
}

func (s *TsIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsIdentifierContext) TS_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ZggParserTS_IDENTIFIER, 0)
}

func (s *TsIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ZggParserVisitor:
		return t.VisitTsIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ZggParser) TsItem() (localctx ITsItemContext) {
	localctx = NewTsItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ZggParserRULE_tsItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ZggParserTS_RAW:
		localctx = NewTsRawContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Match(ZggParserTS_RAW)
		}

	case ZggParserTS_IDENTIFIER:
		localctx = NewTsIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Match(ZggParserTS_IDENTIFIER)
		}

	case ZggParserTS_EXPR_START:
		localctx = NewTsExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(757)
			p.Match(ZggParserTS_EXPR_START)
		}
		{
			p.SetState(758)
			p.expr(0)
		}
		{
			p.SetState(759)
			p.Match(ZggParserR_CURLY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *ZggParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 11:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 18:
		var t *LvalContext = nil
		if localctx != nil {
			t = localctx.(*LvalContext)
		}
		return p.Lval_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ZggParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 31)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ZggParser) Lval_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
